<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Character Sheet Creator</title>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/yaml@2.4.5/browser/yaml.min.js"></script>
    <link rel="stylesheet" href="charsheet.css">
</head>
<body>
    <h1>D&D Character Sheet Creator</h1>
    <div style="text-align: center; font-size: 0.8em; color: #666; margin-bottom: 1em;">
        Version: eggplant
    </div>
    
    <div style="text-align: center; margin: 1em 0; padding: 1em; background-color: #f4f4f4; border-radius: 4px;">
        <div style="margin-bottom: 0.5em;">
            <input type="file" id="yaml-file" accept=".yaml,.yml" style="display: none;" onchange="loadYAMLFile(event)">
            <button type="button" class="add-button" onclick="document.getElementById('yaml-file').click()">Load YAML File</button>
            <button type="button" class="add-button" onclick="downloadYAML()">Download <tt>character.yaml</tt></button>
        </div>
        <div style="margin-bottom: 0.5em;">
            <button type="button" id="generate-pdf-button" class="generate-button" onclick="generatePDF()" disabled>Generate PDF</button>
            <div style="display: inline-block; margin-left: 1em; vertical-align: top; text-align: left;">
                <div style="margin-bottom: 0.3em;">
                    <label>
                        <input type="radio" name="layout" value="silverpine" checked>
                        Two unequal columns (Silverpine Watch style)
                    </label>
                </div>
                <div style="margin-bottom: 0.3em;">
                    <label>
                        <input type="radio" name="layout" value="3col">
                        Three equal columns
                    </label>
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="color" checked>
                        Use colored backgrounds
                    </label>
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="pregenerated" name="pregenerated">
                        Label as pregenerated character
                    </label>
                </div>  
                <div>
                    <label>
                        <input type="checkbox" id="stones" name="stones">
                        Organize equipment by weight, using
                        <a href="https://thealexandrian.net/wordpress/46824/roleplaying-games/5e-encumbrance-by-stone">
                        Alexandrian stones</a>
                    </label>

            </div>
        </div>
    </div>

    <!-- Sample YAML Section -->
    <div style="text-align: left; margin: 1.5em 0; padding: 1em; background-color: #f4f4f4; border-radius: 4px;">
        <div style="margin-bottom: 0.5em;">
            <select id="sample-yaml-dropdown-3col" style="padding: 0.3em;">
                <option value="">Try a pregenerated character (best at 3 cols)</option>
            </select>
            <button type="button" id="load-sample-button-3col" class="add-button" onclick="loadSampleYAML('3col')" style="margin-right: 0.5em;" disabled>Load this character</button>
        </div>
        <div style="margin-bottom: 0.5em;">
            <select id="sample-yaml-dropdown-2col" style="padding: 0.3em;">
                <option value="">Try a pregenerated character (best at 2 cols)</option>
            </select>
            <button type="button" id="load-sample-button-2col" class="add-button" onclick="loadSampleYAML('2col')" style="margin-right: 0.5em;" disabled>Load this character</button>
        </div>
    </div>

    <div id="status-bar" style="text-align: center; margin: 0.5em 0; font-size: 0.9em; color: #666; min-height: 1.2em;">
        <strong>Tip:</strong> Use <kbd>Ctrl+Enter</kbd> (or <kbd>Cmd+Enter</kbd> on Mac) to quickly add items when focused in Attacks, Spells, or Features sections
    </div>
    
    <form id="character-form">
        <!-- Character Info Section -->
        <div class="section sheet-section playername">
            <h2>Character Info</h2>
            <div class="field-row">
                <div class="field wide">
                    <label for="character-name">Character Name</label>
                    <input type="text" id="character-name" name="character-name">
                </div>
                <div class="field wide">
                    <label for="player-name">Player Name</label>
                    <input type="text" id="player-name" name="player-name">
                </div>
            </div>
            <div class="field-row">
                <div class="field">
                    <label for="age">Age</label>
                    <input type="text" id="age" name="age" placeholder="e.g., young adult">
                </div>
            </div>
            <div class="field-row">
                <div class="field">
                    <label for="description">Physical Description</label>
                    <textarea id="description" name="description" rows="3" placeholder="e.g., tall, dark hair, piercing blue eyes"></textarea>
                </div>
            </div>
            <div class="field-row">
                <div class="field">
                    <label for="class">Class</label>
                    <select id="class" name="class">
                        <option value="">Select Class</option>
                        <option value="Barbarian">Barbarian</option>
                        <option value="Bard">Bard</option>
                        <option value="Cleric">Cleric</option>
                        <option value="Druid">Druid</option>
                        <option value="Fighter">Fighter</option>
                        <option value="Monk">Monk</option>
                        <option value="Paladin">Paladin</option>
                        <option value="Ranger">Ranger</option>
                        <option value="Rogue">Rogue</option>
                        <option value="Sorcerer">Sorcerer</option>
                        <option value="Warlock">Warlock</option>
                        <option value="Wizard">Wizard</option>
                    </select>
                </div>
                <div class="field">
                    <label for="level">Level</label>
                    <input type="number" id="level" name="level" min="1" max="20">
                </div>
                <div class="field">
                    <label for="specialty">Specialty</label>
                    <input type="text" id="specialty" name="specialty" placeholder="e.g., Life Domain, Champion">
                </div>
                <div class="field">
                    <label for="race">Race</label>
                    <input type="text" id="race" name="race">
                </div>
            </div>
            <div class="field-row">
                <div class="field wide">
                    <label for="background">Background</label>
                    <input type="text" id="background" name="background">
                </div>
                <div class="field">
                    <label for="alignment">Alignment</label>
                    <input type="text" id="alignment" name="alignment">
                </div>
                <div class="field">
                    <label for="experience">Experience Points</label>
                    <input type="text" id="experience" name="experience">
                </div>
            </div>
            <div class="field-group">
                <label for="motivation">Motivation</label>
                <input type="text" id="motivation" name="motivation" placeholder="Character's personal motivation" style="width: 100%;">
            </div>
        </div>

        <!-- Stats Section -->
        <div class="section sheet-section stats">
            <h2>Ability Scores</h2>
            <div class="ability-scores">
                <div class="field">
                    <label for="str">Strength</label>
                    <input type="number" id="str" name="str" min="1" max="30">
                </div>
                <div class="field">
                    <label for="dex">Dexterity</label>
                    <input type="number" id="dex" name="dex" min="1" max="30">
                </div>
                <div class="field">
                    <label for="con">Constitution</label>
                    <input type="number" id="con" name="con" min="1" max="30">
                </div>
                <div class="field">
                    <label for="int">Intelligence</label>
                    <input type="number" id="int" name="int" min="1" max="30">
                </div>
                <div class="field">
                    <label for="wis">Wisdom</label>
                    <input type="number" id="wis" name="wis" min="1" max="30">
                </div>
                <div class="field">
                    <label for="cha">Charisma</label>
                    <input type="number" id="cha" name="cha" min="1" max="30">
                </div>
            </div>
        </div>

        <!-- Combat Stats Section -->
        <div class="section sheet-section hpetc">
            <h2>Combat Stats</h2>
            <div class="field-row">
                <div class="field">
                    <label for="max-hp">Max HP</label>
                    <input type="number" id="max-hp" name="max-hp" min="1">
                </div>
                <div class="field">
                    <label for="hit-dice">Hit Die</label>
                    <select id="hit-dice" name="hit-dice">
                        <option value="">Select</option>
                        <option value="d6">d6</option>
                        <option value="d8">d8</option>
                        <option value="d10">d10</option>
                        <option value="d12">d12</option>
                    </select>
                </div>
            </div>
            <div class="field-row">
                <div class="field">
                    <label for="initiative">Initiative</label>
                    <input type="text" id="initiative" name="initiative" placeholder="+1">
                </div>
                <div class="field">
                    <label for="speed">Speed</label>
                    <input type="text" id="speed" name="speed" placeholder="30">
                </div>
                <div class="field">
                    <label for="armor-class">Armor Class</label>
                    <input type="number" id="armor-class" name="armor-class" min="1">
                </div>
            </div>
            <div class="field-row">
                <div class="field wide">
                    <label for="senses">Senses</label>
                    <input type="text" id="senses" name="senses" placeholder="Darkvision 60 ft.">
                </div>
                <div class="field">
                    <label for="passive-perception">Passive Perception</label>
                    <input type="number" id="passive-perception" name="passive-perception" min="1">
                </div>
            </div>
        </div>

        <!-- Proficiencies Section -->
        <div class="section sheet-section proficiencies">
            <h2>Proficiencies</h2>
            <input type="hidden" id="proficiency-bonus" name="proficiency-bonus">
            <div class="field-group">
                <p>Enter one proficiency per line. Include skill, language, and equipment proficiencies. Leave a blank line between categories.</p>
                <textarea id="proficiencies-text" name="proficiencies-text" rows="8" placeholder="Athletics&#10;Medicine&#10;Nature&#10;&#10;Common&#10;Orcish&#10;&#10;Light Armor&#10;Shield&#10;Simple Weapons" style="width: 100%; box-sizing: border-box;"></textarea>
            </div>
        </div>

        <!-- Attacks Section -->
        <div class="section sheet-section attacks">
            <h2>Attacks</h2>
            <div id="attacks-list">
                <!-- Dynamic attacks will be added here -->
            </div>
            <button type="button" class="add-button" onclick="addAttack()">Add Attack</button>
        </div>

        <!-- Magic Section -->
        <div class="section sheet-section magic" id="magic-section">
            <h2 id="magic-header" onclick="toggleMagic()" style="cursor: pointer;">Magic (click to open)</h2>
            <div id="magic-content" style="display: none;">
                <div class="field-group render-options" style="margin-bottom: 1em;">
                    <span>Render:</span>
                    <div style="margin-top: 0.5em;">
                        <label>
                            <input type="radio" name="magic-render" value="normalsize"> at normal size
                        </label>
                        <label>
                            <input type="radio" name="magic-render" value="small" checked> in a smaller font
                        </label>
                        <label>
                            <input type="radio" name="magic-render" value="footnotesize"> in an even smaller font
                        </label>
<!--
                        <label style="display: block; margin-bottom: 0.3em; font-weight: normal;">
                            <input type="radio" name="magic-render" value="separate"> on a page of its own
-->
                        </label>
                    </div>
                </div>
                <div id="magic-levels">
                    <!-- Spell levels are added dynamically as needed -->
                </div>
                <div id="next-level-button-container">
                    <!-- Next level button will appear here -->
                </div>
            </div>
        </div>

        <!-- Features Section -->
        <div class="section sheet-section features">
            <h2>Features</h2>
            <div class="field-group render-options" style="margin-bottom: 1em;">
                <span>Render:</span>
                <div style="margin-top: 0.5em;">
                    <label>
                        <input type="radio" name="features-render" value="normalsize"> at normal size
                    </label>
                    <label>
                        <input type="radio" name="features-render" value="small" checked> in a smaller font
                    </label>
                    <label>
                        <input type="radio" name="features-render" value="footnotesize"> in an even smaller font
                    </label>
                </div>
            </div>
            <div id="features-list">
                <!-- Dynamic features will be added here -->
            </div>
            <button type="button" class="add-button" onclick="addFeature()">Add Feature</button>
        </div>

        <!-- Equipment Section -->
        <div class="section sheet-section equipment">
            <h2>Equipment</h2>
            <div class="field-group">
                <p>Enter one equipment item per line. Or you scan specify categories:</p>
                <ul style="font-size: 0.9em; margin: 0.5em 0; color: #666;">
                    <li><code>Heavy weapon: Greatsword</code> (single item)</li>
                    <li><code>Slotted items:</code> followed by <code>- Backpack</code>, <code>- Rations</code> (multiple items)</li>
                </ul>
                <textarea id="equipment-text" name="equipment-text" rows="6" placeholder="Scale Mail Armor&#10;Shield (+2 AC)&#10;Backpack&#10;Bedroll&#10;Mess Kit&#10;Torches (10)&#10;Rations (10)&#10;Waterskin" style="width: 100%; box-sizing: border-box;"></textarea>

                <div style="margin-top: 0.5em; display: none; gap: 0.5em; flex-wrap: wrap;">
                    <button type="button" class="add-button" onclick="convertStructuredToLines()" title="Convert your equipment list to the new categorized format">
                        📝 Categorize Equipment
                    </button>
                    <button type="button" class="add-button" onclick="convertEquipmentToStructured()" title="Show how your equipment would be parsed into categories">
                        🔍 Preview Categories
                    </button>
                    <button type="button" class="add-button" onclick="testEquipmentParsing()" title="Run tests to verify the equipment parsing system works correctly">
                        🧪 Test Parser
                    </button>
                </div>
            </div>
            
            <h3>Currency</h3>
            <div class="currency-fields">
                <div class="field">
                    <label for="cp">Copper (CP)</label>
                    <input type="text" id="cp" name="cp">
                </div>
                <div class="field">
                    <label for="sp">Silver (SP)</label>
                    <input type="text" id="sp" name="sp">
                </div>
                <div class="field" style="display: none;">
                    <label for="ep">Electrum (EP)</label>
                    <input type="text" id="ep" name="ep">
                </div>
                <div class="field">
                    <label for="gp">Gold (GP)</label>
                    <input type="text" id="gp" name="gp">
                </div>
                <div class="field">
                    <label for="pp">Platinum (PP)</label>
                    <input type="text" id="pp" name="pp">
                </div>
            </div>
        </div>

    </form>


    <script>
        // Embedded YAML data - will be populated by insert-pregen-yamls script
        // EMBEDDED_YAMLS_PLACEHOLDER

        // Sample YAML loading functions
        function populateSampleDropdown() {
            const dropdown3col = document.getElementById('sample-yaml-dropdown-3col');
            const dropdown2col = document.getElementById('sample-yaml-dropdown-2col');
            const button3col = document.getElementById('load-sample-button-3col');
            const button2col = document.getElementById('load-sample-button-2col');

            if (!dropdown3col || !dropdown2col || typeof EMBEDDED_YAMLS === 'undefined') return;

            // Clear existing options except the first one
            while (dropdown3col.children.length > 1) {
                dropdown3col.removeChild(dropdown3col.lastChild);
            }
            while (dropdown2col.children.length > 1) {
                dropdown2col.removeChild(dropdown2col.lastChild);
            }

            // Parse each YAML to get layout, then add to appropriate dropdown
            EMBEDDED_YAMLS.forEach((yamlData, index) => {
                try {
                    const parsed = jsyaml.load(yamlData.content);
                    const layout = parsed.LAYOUT;
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = yamlData.origin;

                    // Filter by layout: 3col goes in first dropdown, silverpine/unspecified in second
                    if (layout === '3col') {
                        dropdown3col.appendChild(option);
                    } else {
                        dropdown2col.appendChild(option);
                    }
                } catch (e) {
                    console.error('Error parsing YAML for layout:', e);
                }
            });

            // Add event listeners to enable/disable buttons based on selection
            dropdown3col.addEventListener('change', function() {
                if (button3col) {
                    button3col.disabled = (this.value === '');
                }
            });

            dropdown2col.addEventListener('change', function() {
                if (button2col) {
                    button2col.disabled = (this.value === '');
                }
            });

            // Ensure buttons start disabled
            if (button3col) button3col.disabled = true;
            if (button2col) button2col.disabled = true;
        }

        function loadSampleYAML(layoutType) {
            const dropdownId = layoutType === '3col' ? 'sample-yaml-dropdown-3col' : 'sample-yaml-dropdown-2col';
            const dropdown = document.getElementById(dropdownId);
            const selectedIndex = dropdown.value;

            if (selectedIndex === '' || typeof EMBEDDED_YAMLS === 'undefined') {
                updateStatusBar('Please select a character from the dropdown.', true);
                return;
            }

            const yamlData = EMBEDDED_YAMLS[selectedIndex];
            if (!yamlData) {
                updateStatusBar('Error: Selected character data not found.', true);
                return;
            }

            try {
                // Use the existing parseYAMLIntoForm function
                parseYAMLIntoForm(yamlData.content);
                loadedFileName = yamlData.origin + '.yaml';
                isDirty = false;
                updateStatusBar('Loaded sample character: ' + yamlData.origin);
                updateDownloadButtonText();
                setupChangeTracking();
            } catch (error) {
                updateStatusBar('Error loading sample character: ' + error.message, true);
            }
        }

        // Initialize with some default entries
        document.addEventListener('DOMContentLoaded', function() {
            addAttack();
            addFeature();
            setupChangeTracking();

            // Populate sample YAML dropdown
            populateSampleDropdown();

            // Initialize and update download button text
            updateDownloadButtonText();
            const characterNameField = document.getElementById('character-name');
            const classField = document.getElementById('class');
            characterNameField.addEventListener('input', updateDownloadButtonText);
            characterNameField.addEventListener('change', updateDownloadButtonText);
            classField.addEventListener('input', updateDownloadButtonText);
            classField.addEventListener('change', updateDownloadButtonText);
        });

        // Global keyboard shortcut handler
        document.addEventListener('keydown', function(event) {
            // Check for Ctrl+Enter (or Cmd+Enter on Mac)
            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                event.preventDefault();
                
                // Find which section the focus is in
                const activeElement = document.activeElement;
                const attacksSection = document.getElementById('attacks-list');
                const magicSection = document.getElementById('magic-list');
                const featuresSection = document.getElementById('features-list');
                
                // Check if focus is within any of these sections
                if (attacksSection && attacksSection.contains(activeElement)) {
                    addAttack();
                    // Focus on the name field of the new attack
                    setTimeout(() => {
                        const newAttack = document.querySelector('.attack-item:last-child [data-field="name"]');
                        if (newAttack) newAttack.focus();
                    }, 10);
                } else if (magicSection && magicSection.contains(activeElement)) {
                    // Find which spell level section we're in
                    const spellLevelDiv = activeElement.closest('.spell-level');
                    const level = spellLevelDiv ? spellLevelDiv.getAttribute('data-level') : '0';
                    addSpellToLevel(parseInt(level));
                    // Focus on the name field of the new spell
                    setTimeout(() => {
                        const container = spellLevelDiv.querySelector('.spells-container');
                        const newSpell = container ? container.querySelector('.spell-item:last-child [data-field="name"]') : null;
                        if (newSpell) newSpell.focus();
                    }, 10);
                } else if (featuresSection && featuresSection.contains(activeElement)) {
                    addFeature();
                    // Focus on the name field of the new feature
                    setTimeout(() => {
                        const newFeature = document.querySelector('.feature-item:last-child [data-field="name"]');
                        if (newFeature) newFeature.focus();
                    }, 10);
                } else {
                    // If not in a specific section, check which section is closest or most recently used
                    // Default to adding an attack
                    addAttack();
                    setTimeout(() => {
                        const newAttack = document.querySelector('.attack-item:last-child [data-field="name"]');
                        if (newAttack) newAttack.focus();
                    }, 10);
                }
            }
        });

        function toggleMagic() {
            const magicContent = document.getElementById('magic-content');
            const magicHeader = document.getElementById('magic-header');
            
            if (magicContent.style.display === 'none') {
                magicContent.style.display = 'block';
                magicHeader.textContent = 'Magic';
                // Always open cantrips automatically when magic section opens
                if (!document.querySelector('[data-level="0"]')) {
                    openSpellLevel(0);
                }
            } else {
                magicContent.style.display = 'none';
                magicHeader.textContent = 'Magic (click to open)';
            }
        }
        
        function getSpellLevelName(level) {
            if (level === 0) return 'Cantrips';
            const suffixes = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th'];
            return `${level}${suffixes[level]}-Level Spells`;
        }
        
        function openSpellLevel(level) {
            const magicLevels = document.getElementById('magic-levels');
            const levelDiv = document.createElement('div');
            levelDiv.className = 'spell-level';
            levelDiv.setAttribute('data-level', level);
            
            const levelName = level === 0 ? 'Cantrips' : `${getSpellLevelName(level)} (<input type="number" min="0" max="9" maxlength="1" data-slots="${level}" placeholder="0" style="width: 2.5em; border: 1px solid #999; text-align: center;"> slots)`;
            
            levelDiv.innerHTML = `
                <h3>${levelName}</h3>
                <div class="spells-container"></div>
                <button type="button" class="add-button" onclick="addSpellToLevel(${level})">Add ${level === 0 ? 'Cantrip' : getSpellLevelName(level).replace('-Level Spells', '-Level Spell')}</button>
            `;
            
            magicLevels.appendChild(levelDiv);
            
            // Add change tracking for the new slot input if it exists
            const slotsInputEl = levelDiv.querySelector('[data-slots]');
            if (slotsInputEl) {
                slotsInputEl.addEventListener('input', markDirty);
                slotsInputEl.addEventListener('change', markDirty);
            }
            
            updateNextLevelButton();
        }
        
        function showNextLevelButton(level) {
            const container = document.getElementById('next-level-button-container');
            const nextLevel = level;
            const maxLevel = 9;
            
            if (nextLevel <= maxLevel) {
                const levelName = nextLevel === 0 ? 'Cantrips' : getSpellLevelName(nextLevel);
                container.innerHTML = `
                    <button type="button" class="add-button" onclick="openSpellLevel(${nextLevel}); addSpellToLevel(${nextLevel});">Open ${levelName}</button>
                `;
            } else {
                container.innerHTML = '';
            }
        }
        
        function updateNextLevelButton() {
            const existingLevels = Array.from(document.querySelectorAll('.spell-level')).map(el => parseInt(el.getAttribute('data-level')));
            if (existingLevels.length === 0) {
                showNextLevelButton(0);
                return;
            }
            
            const maxExistingLevel = Math.max(...existingLevels);
            const nextLevel = maxExistingLevel + 1;
            showNextLevelButton(nextLevel);
        }

        function addAttack() {
            const container = document.getElementById('attacks-list');
            const item = document.createElement('div');
            item.style.textAlign = 'left'; // Force left alignment
            item.className = 'attack-item';
            item.innerHTML = `
                <input type="hidden" data-field="original-name" />
                <div class="attack-fields">
                    <input type="text" placeholder="Weapon" data-field="name" />
                    <input type="text" placeholder="Attack Bonus" data-field="attack" />
                    <input type="text" placeholder="Damage Amount" data-field="damage" />
                    <input type="text" placeholder="Damage Type" data-field="type" list="damage-types" />
                    <datalist id="damage-types">
                        <option value="slashing">
                        <option value="piercing">
                        <option value="bludgeoning">
                        <option value="acid">
                        <option value="cold">
                        <option value="fire">
                        <option value="force">
                        <option value="lightning">
                        <option value="necrotic">
                        <option value="poison">
                        <option value="psychic">
                        <option value="radiant">
                        <option value="thunder">
                    </datalist>
                    <input type="text" placeholder="Range" data-field="range" class="range-field" />
                </div>
                <button type="button" onclick="this.parentElement.remove()">Remove Attack</button>
            `;
            container.appendChild(item);
            
            // Add change tracking to new elements
            item.querySelectorAll('input, textarea, select').forEach(el => {
                el.addEventListener('input', markDirty);
                el.addEventListener('change', markDirty);
            });
        }

        function addSpellToLevel(level) {
            // Ensure the level exists first
            let spellLevelDiv = document.querySelector(`[data-level="${level}"]`);
            if (!spellLevelDiv) {
                openSpellLevel(level);
                spellLevelDiv = document.querySelector(`[data-level="${level}"]`);
            }
            
            const spellContainer = spellLevelDiv.querySelector('.spells-container');
            const item = document.createElement('div');
            item.className = 'spell-item';
            item.innerHTML = `
                <input type="hidden" data-field="original-name" />
                <div class="field-group">
                    <label>Name</label>
                    <input type="text" placeholder="e.g., Magic Missile" data-field="name" data-level="${level}" />
                </div>
                <div class="field-group">
                    <label>Description</label>
                    <textarea placeholder="Spell description..." data-field="description" rows="2"></textarea>
                </div>
                <button type="button" onclick="this.parentElement.remove(); setupChangeTracking();">Remove Spell</button>
            `;
            spellContainer.appendChild(item);
            
            // Add change tracking to new elements
            item.querySelectorAll('input, textarea, select').forEach(el => {
                el.addEventListener('input', markDirty);
                el.addEventListener('change', markDirty);
            });
        }
        
        // Legacy function for compatibility
        function addSpell() {
            // Bug fix: addSpell should never be called with arguments; use addSpellToLevel instead
            if (arguments.length > 0) {
                console.error('BUG: addSpell() called with arguments. Use addSpellToLevel() instead.');
                throw new Error('addSpell() should not be called with arguments');
            }
            addSpellToLevel(0); // Default to cantrips
        }

        function addFeature() {
            const container = document.getElementById('features-list');
            const item = document.createElement('div');
            item.className = 'feature-item';
            item.style.textAlign = 'left'; // Force left alignment
            item.innerHTML = `
                <input type="hidden" data-field="original-name" />
                <div style="display: flex; align-items: center; gap: 0.5em; margin-bottom: 0.5em;">
                    <label style="white-space: nowrap;">Name</label>
                    <input type="text" placeholder="e.g., Rage, Darkvision" data-field="name" style="flex: 1;" />
                </div>
                <div style="margin-bottom: 0.5em;">
                    <label style="display: block; margin-bottom: 0.2em;">Description</label>
                    <textarea placeholder="Feature description..." data-field="description" rows="2" style="width: 100%; box-sizing: border-box;"></textarea>
                </div>
                <button type="button" onclick="this.parentElement.remove()">Remove Feature</button>
            `;
            container.appendChild(item);
            
            // Add change tracking to new elements
            item.querySelectorAll('input, textarea, select').forEach(el => {
                el.addEventListener('input', markDirty);
                el.addEventListener('change', markDirty);
            });
        }

        let isDirty = false;
        let loadedFileName = '';
        let originalYamlData = null;  // Stores complete parsed YAML for passthrough of unknown fields
        let originalYamlDoc = null;   // YAML.Document to preserve key order and formatting
        let originalYamlText = '';    // Original YAML text to recreate Document when emitting

        // Deep equality check for primitives, arrays, and plain objects
        function deepEqual(a, b) {
            if (a === b) return true;
            if (typeof a !== typeof b) return false;
            if (a && b && typeof a === 'object') {
                const aIsArr = Array.isArray(a);
                const bIsArr = Array.isArray(b);
                if (aIsArr !== bIsArr) return false;
                if (aIsArr && bIsArr) {
                    if (a.length !== b.length) return false;
                    for (let i = 0; i < a.length; i++) {
                        if (!deepEqual(a[i], b[i])) return false;
                    }
                    return true;
                }
                // Plain object compare
                const aKeys = Object.keys(a);
                const bKeys = Object.keys(b);
                if (aKeys.length !== bKeys.length) return false;
                for (const k of aKeys) {
                    if (!Object.prototype.hasOwnProperty.call(b, k)) return false;
                    if (!deepEqual(a[k], b[k])) return false;
                }
                return true;
            }
            return false;
        }

        // Collect changed paths between original and updated objects
        function collectChanges(orig, upd, basePath = [], out = []) {
            // If identical, nothing to change
            if (deepEqual(orig, upd)) return out;

            const origIsObj = orig && typeof orig === 'object';
            const updIsObj = upd && typeof upd === 'object';
            const origIsArr = Array.isArray(orig);
            const updIsArr = Array.isArray(upd);

            if (updIsArr || origIsArr) {
                // For arrays, if any diff, replace whole array at this path
                out.push({ path: basePath.slice(), value: upd });
                return out;
            }

            if (updIsObj && origIsObj) {
                // Dive recursively for objects to minimize writes
                const keys = new Set([...Object.keys(orig || {}), ...Object.keys(upd || {})]);
                for (const k of keys) {
                    const npath = basePath.concat([k]);
                    if (!deepEqual(orig ? orig[k] : undefined, upd ? upd[k] : undefined)) {
                        const o = orig ? orig[k] : undefined;
                        const u = upd ? upd[k] : undefined;
                        const oIsObj = o && typeof o === 'object' && !Array.isArray(o);
                        const uIsObj = u && typeof u === 'object' && !Array.isArray(u);
                        if (oIsObj && uIsObj) {
                            collectChanges(o, u, npath, out);
                        } else {
                            out.push({ path: npath, value: u });
                        }
                    }
                }
                return out;
            }

            // Primitive or type mismatch: set directly
            out.push({ path: basePath.slice(), value: upd });
            return out;
        }

        function loadYAMLFile(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        parseYAMLIntoForm(e.target.result);
                        loadedFileName = file.name;
                        isDirty = false;
                        updateStatusBar();
                        setupChangeTracking();
                        updateDownloadButtonText();
                    } catch (error) {
                        updateStatusBar('Error loading YAML file: ' + error.message, true);
                    }
                };
                reader.readAsText(file);
            }
        }

        function updateStatusBar(message = null, isError = false) {
            const statusBar = document.getElementById('status-bar');
            if (message) {
                statusBar.innerHTML = `<span style="color: ${isError ? '#d32f2f' : '#666'}">${message}</span>`;
            } else if (loadedFileName) {
                const dirtyMark = isDirty ? ' (not saved)' : '';
                statusBar.innerHTML = `Loaded from <strong>${loadedFileName}</strong>${dirtyMark}`;
            } else {
                statusBar.innerHTML = '<strong>Tip:</strong> Use <kbd>Ctrl+Enter</kbd> (or <kbd>Cmd+Enter</kbd> on Mac) to quickly add items when focused in Attacks, Spells, or Features sections';
            }
        }

        function markDirty() {
            if (!isDirty) {
                isDirty = true;
                updateStatusBar();
            }
            updateGeneratePDFButton();
        }

        function updateGeneratePDFButton() {
            const button = document.getElementById('generate-pdf-button');
            if (!button) return;

            // Check if any form field has content
            const hasContent = Array.from(document.querySelectorAll('#character-form input, #character-form textarea, #character-form select')).some(el => {
                // Skip hidden fields and radio buttons that aren't checked
                if (el.type === 'hidden') return false;
                if (el.type === 'radio' && !el.checked) return false;
                if (el.type === 'checkbox' && !el.checked) return false;

                // Check if field has a value
                return el.value && el.value.trim() !== '';
            });

            button.disabled = !hasContent;
        }

        function setupChangeTracking() {
            // Remove existing listeners first
            document.querySelectorAll('#character-form input, #character-form textarea, #character-form select').forEach(el => {
                el.removeEventListener('input', markDirty);
                el.removeEventListener('change', markDirty);
            });
            
            // Add listeners to all form elements
            document.querySelectorAll('#character-form input, #character-form textarea, #character-form select').forEach(el => {
                el.addEventListener('input', markDirty);
                el.addEventListener('change', markDirty);
                // Update button text when character name or class changes
                if (el.id === 'character-name' || el.id === 'class') {
                    el.addEventListener('input', updateDownloadButtonText);
                }
            });
        }

        // Field factory functions
        function textField(yamlKey, selector) {
            return {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    const value = data[yamlKey];
                    if (el && value !== undefined && value !== null) {
                        el.value = value.toString();
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    data[yamlKey] = el?.value || '';
                }
            };
        }

        function numberField(yamlKey, selector) {
            return {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    const value = data[yamlKey];
                    if (el && value !== undefined && value !== null) {
                        el.value = value.toString();
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    const value = el?.value || '';
                    data[yamlKey] = value ? (parseInt(value) || value) : value;
                }
            };
        }

        function checkboxField(yamlKey, selector, defaultState = false) {
            return {
                populate(data) {
                    const el = document.querySelector(selector);
                    if (el) {
                        const value = data[yamlKey];
                        console.log(`${yamlKey} value:`, value, 'type:', typeof value);
                        // Use default state if yamlKey is not present in data
                        const shouldCheck = value !== undefined ? !ifDNDfalse(value) : defaultState;
                        console.log('Should check:', shouldCheck);
                        el.checked = shouldCheck;
                    }
                },
                capture(data) {
                    const el = document.querySelector(selector);
                    data[yamlKey] = el?.checked || false;
                }
            };
        }

        function radioField(yamlKey, name) {
            return {
                populate(data) {
                    const value = data[yamlKey];
                    if (value !== undefined && value !== null) {
                        const radio = document.querySelector(`input[name="${name}"][value="${value}"]`);
                        if (radio) {
                            radio.checked = true;
                        }
                    }
                },
                capture(data) {
                    const checkedRadio = document.querySelector(`input[name="${name}"]:checked`);
                    if (checkedRadio) {
                        data[yamlKey] = checkedRadio.value;
                    }
                }
            };
        }

        // Complex field factories
        function arrayField(yamlKey, selector, itemProcessor = null) {
            return {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    if (el && data[yamlKey] && Array.isArray(data[yamlKey])) {
                        const items = itemProcessor 
                            ? data[yamlKey].map(itemProcessor)
                            : data[yamlKey].map(item => item?.toString() || '');
                        el.value = items.join('\n');
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    const text = el?.value || '';
                    if (text.trim()) {
                        const lines = text.split('\n').filter(line => line.trim());
                        data[yamlKey] = itemProcessor ? lines.map(itemProcessor) : lines;
                    } else {
                        data[yamlKey] = [];
                    }
                }
            };
        }

        function classLevelField() {
            return {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const setFormValue = (selector, value) => {
                        const el = form.querySelector(selector);
                        if (el && value !== undefined && value !== null) {
                            el.value = value.toString();
                        }
                    };
                    
                    // Handle "CLASS & LEVEL" format
                    if (data['CLASS & LEVEL']) {
                        const classLevel = data['CLASS & LEVEL'].toString();

                        // Try patterns in order: specialty format first, then simple format
                        let match = classLevel.match(/^([A-Za-z]+)\s*\(([^)]+)\)\s+(\d+)$/);
                        if (match) {
                            // Format: "Cleric (Life Domain) 1"
                            setFormValue('#class', match[1]);
                            setFormValue('#specialty', match[2]);
                            setFormValue('#level', match[3]);
                        } else {
                            match = classLevel.match(/^([A-Za-z]+)\s+(\d+)$/);
                            if (match) {
                                // Format: "Fighter 1"
                                setFormValue('#class', match[1]);
                                setFormValue('#level', match[2]);
                            } else {
                                match = classLevel.match(/^([A-Za-z]+)/);
                                if (match) {
                                    // Format: just class name
                                    setFormValue('#class', match[1]);
                                }
                            }
                        }
                    }
                    
                    // Override with individual fields if present
                    if (data['CLASS']) setFormValue('#class', data['CLASS']);
                    if (data['LEVEL']) setFormValue('#level', data['LEVEL']);
                    if (data['SPECIALTY']) setFormValue('#specialty', data['SPECIALTY']);
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const characterClass = form.querySelector('#class')?.value || '';
                    const level = form.querySelector('#level')?.value || '';
                    const specialty = form.querySelector('#specialty')?.value || '';

                    data['CLASS'] = characterClass;
                    data['LEVEL'] = level ? (parseInt(level) || level) : level;
                    if (specialty) data['SPECIALTY'] = specialty;
                }
            };
        }

        // Name-description pair handler - reusable for Features and Magic
        function nameDescPairs(yamlKey, itemSelector, addFunction) {
            return {
                populate(data) {
                    if (data[yamlKey] && Array.isArray(data[yamlKey])) {
                        // Clear existing items first
                        document.querySelectorAll(itemSelector).forEach(item => item.remove());
                        
                        data[yamlKey].forEach(item => {
                            if (item && typeof item === 'object' && item.name) {
                                addFunction();
                                const items = document.querySelectorAll(itemSelector);
                                const lastItem = items[items.length - 1];
                                if (lastItem) {
                                    const nameEl = lastItem.querySelector('[data-field="name"]');
                                    const descEl = lastItem.querySelector('[data-field="description"]');
                                    const originalNameEl = lastItem.querySelector('[data-field="original-name"]');
                                    if (nameEl) nameEl.value = item.name || '';
                                    if (descEl) descEl.value = item.description || '';
                                    if (originalNameEl) originalNameEl.value = item.name || '';
                                }
                            }
                        });
                    }
                },
                capture(data) {
                    const items = [];
                    document.querySelectorAll(itemSelector).forEach(itemDiv => {
                        const name = itemDiv.querySelector('[data-field="name"]')?.value || '';
                        const description = itemDiv.querySelector('[data-field="description"]')?.value || '';
                        const originalName = itemDiv.querySelector('[data-field="original-name"]')?.value || '';

                        if (name || description) {
                            // Try to find original item by original-name to preserve extra tags
                            let item = {};
                            if (originalName && originalYamlData && originalYamlData[yamlKey] && Array.isArray(originalYamlData[yamlKey])) {
                                const originalItem = originalYamlData[yamlKey].find(i => i && i.name === originalName);
                                if (originalItem) {
                                    // Start with original item to preserve all extra tags
                                    item = { ...originalItem };
                                }
                            }
                            // Update name and description (possibly changed from original)
                            if (name) item.name = name;
                            if (description) item.description = description;
                            items.push(item);
                        }
                    });
                    data[yamlKey] = items;
                }
            };
        }

        // Attacks field factory
        function attacksField() {
            return {
                populate(data) {
                    if (data['ATTACKS'] && Array.isArray(data['ATTACKS'])) {
                        // Clear existing attacks first
                        document.querySelectorAll('.attack-item').forEach(item => item.remove());
                        
                        data['ATTACKS'].forEach(attack => {
                            if (attack && typeof attack === 'object') {
                                addAttack();
                                const items = document.querySelectorAll('.attack-item');
                                const lastItem = items[items.length - 1];
                                if (lastItem) {
                                    const nameEl = lastItem.querySelector('[data-field="name"]');
                                    const attackEl = lastItem.querySelector('[data-field="attack"]');
                                    const damageEl = lastItem.querySelector('[data-field="damage"]');
                                    const typeEl = lastItem.querySelector('[data-field="type"]');
                                    const rangeEl = lastItem.querySelector('[data-field="range"]');
                                    const originalNameEl = lastItem.querySelector('[data-field="original-name"]');

                                    if (nameEl) nameEl.value = attack['NAME'] || '';
                                    if (attackEl) attackEl.value = attack['ATTACK'] || '';
                                    if (damageEl) damageEl.value = attack['DAMAGE'] || '';
                                    if (typeEl) typeEl.value = attack['TYPE'] || '';
                                    if (rangeEl) rangeEl.value = attack['RANGE'] || '';
                                    if (originalNameEl) originalNameEl.value = attack['NAME'] || '';
                                }
                            }
                        });
                    }
                },
                capture(data) {
                    const attacks = [];
                    document.querySelectorAll('.attack-item').forEach(attackDiv => {
                        const name = attackDiv.querySelector('[data-field="name"]')?.value || '';
                        const attack = attackDiv.querySelector('[data-field="attack"]')?.value || '';
                        const damage = attackDiv.querySelector('[data-field="damage"]')?.value || '';
                        const type = attackDiv.querySelector('[data-field="type"]')?.value || '';
                        const range = attackDiv.querySelector('[data-field="range"]')?.value || '';
                        const originalName = attackDiv.querySelector('[data-field="original-name"]')?.value || '';

                        if (name || attack || damage || type || range) {
                            // Try to find original attack by original-name to preserve extra fields
                            let attackObj = {};
                            if (originalName && originalYamlData && originalYamlData['ATTACKS'] && Array.isArray(originalYamlData['ATTACKS'])) {
                                const originalAttack = originalYamlData['ATTACKS'].find(a => a && a.NAME === originalName);
                                if (originalAttack) {
                                    // Start with original attack to preserve all extra fields (NOTES, AMMO TYPE, AMMO COUNT, etc.)
                                    attackObj = { ...originalAttack };
                                    // Remove obsolete AMMO field if present (replaced by AMMO TYPE and AMMO COUNT)
                                    delete attackObj['AMMO'];
                                }
                            }
                            // Update main fields (possibly changed from original)
                            attackObj['NAME'] = name;
                            attackObj['ATTACK'] = attack;
                            attackObj['DAMAGE'] = damage;
                            attackObj['TYPE'] = type;
                            // Set RANGE if non-empty, otherwise remove it
                            if (range) {
                                attackObj['RANGE'] = range;
                            } else {
                                delete attackObj['RANGE'];
                            }
                            attacks.push(attackObj);
                        }
                    });
                    data['ATTACKS'] = attacks;
                }
            };
        }

        // Magic field factory
        function magicField() {
            return {
                populate(data) {
                    if (data['MAGIC'] && Array.isArray(data['MAGIC'])) {
                        // Auto-open magic section
                        const magicContent = document.getElementById('magic-content');
                        const magicHeader = document.getElementById('magic-header');
                        if (magicContent && magicContent.style.display === 'none') {
                            magicContent.style.display = 'block';
                            magicHeader.textContent = 'Magic';
                        }
                        
                        // Clear existing spells first
                        document.querySelectorAll('.spell-item').forEach(item => item.remove());
                        
                        let currentLevel = null;
                        data['MAGIC'].forEach(item => {
                            if (item.level !== undefined) {
                                // This is a level header
                                if (typeof item.level === 'number') {
                                    currentLevel = item.level;
                                } else if (typeof item.level === 'object' && item.level.number !== undefined) {
                                    currentLevel = item.level.number;
                                    // Set slot count if provided
                                    const slotsInput = document.querySelector(`[data-slots="${currentLevel}"]`);
                                    if (slotsInput && item.level.slots !== undefined) {
                                        slotsInput.value = item.level.slots;
                                    }
                                }
                            } else if (item.name && currentLevel !== null) {
                                // This is a spell
                                addSpellToLevel(currentLevel);
                                const levelDiv = document.querySelector(`[data-level="${currentLevel}"]`);
                                const spellItems = levelDiv?.querySelectorAll('.spell-item');
                                const lastItem = spellItems?.[spellItems.length - 1];
                                if (lastItem) {
                                    const nameEl = lastItem.querySelector('[data-field="name"]');
                                    const descEl = lastItem.querySelector('[data-field="description"]');
                                    const originalNameEl = lastItem.querySelector('[data-field="original-name"]');
                                    if (nameEl) nameEl.value = item.name || '';
                                    if (descEl) descEl.value = item.description || '';
                                    if (originalNameEl) originalNameEl.value = item.name || '';
                                }
                            }
                        });
                    }
                },
                capture(data) {
                    const magic = [];
                    const magicLevels = document.querySelectorAll('.spell-level');
                    let hasMagic = false;
                    
                    magicLevels.forEach(levelDiv => {
                        const level = levelDiv.getAttribute('data-level');
                        const spellItems = levelDiv.querySelectorAll('.spell-item');
                        const slotsInput = levelDiv.querySelector(`[data-slots="${level}"]`);
                        
                        if (spellItems.length > 0) {
                            // Add level header with slot information
                            if (level === '0') {
                                magic.push({ level: 0 });
                            } else {
                                let slots = slotsInput?.value || '';
                                // If no slots in form, try to preserve from original data
                                if (!slots && originalYamlData && originalYamlData['MAGIC'] && Array.isArray(originalYamlData['MAGIC'])) {
                                    const originalLevelHeader = originalYamlData['MAGIC'].find(i =>
                                        i && i.level !== undefined &&
                                        (i.level === parseInt(level) ||
                                         (typeof i.level === 'object' && i.level.number === parseInt(level)))
                                    );
                                    if (originalLevelHeader && typeof originalLevelHeader.level === 'object') {
                                        slots = originalLevelHeader.level.slots;
                                    }
                                }

                                if (slots) {
                                    magic.push({ level: { number: parseInt(level), slots: parseInt(slots) } });
                                } else {
                                    magic.push({ level: parseInt(level) });
                                }
                            }
                            
                            // Add spells for this level
                            spellItems.forEach(spellDiv => {
                                const name = spellDiv.querySelector('[data-field="name"]')?.value || '';
                                const description = spellDiv.querySelector('[data-field="description"]')?.value || '';
                                const originalName = spellDiv.querySelector('[data-field="original-name"]')?.value || '';

                                if (name || description) {
                                    hasMagic = true;
                                    // Try to find original spell by original-name to preserve extra tags
                                    let spell = {};
                                    if (originalName && originalYamlData && originalYamlData['MAGIC'] && Array.isArray(originalYamlData['MAGIC'])) {
                                        // Find spell in original data (skip level headers)
                                        const originalSpell = originalYamlData['MAGIC'].find(i => i && i.name === originalName && i.level === undefined);
                                        if (originalSpell) {
                                            // Start with original spell to preserve all extra tags
                                            spell = { ...originalSpell };
                                        }
                                    }
                                    // Update name and description (possibly changed from original)
                                    if (name) spell.name = name;
                                    if (description) spell.description = description;
                                    magic.push(spell);
                                }
                            });
                        }
                    });
                    
                    if (hasMagic) {
                        data['MAGIC'] = magic;
                    }
                }
            };
        }

        // Helper function to format proficiency items for display
        function stringOfProficienciesEntry(item) {
            // Null items render as empty string (for spacing in form)
            if (item === null) return '';
            if (typeof item === 'string') return item;
            if (item && item.proficiencies_skip) return '';
            if (item && typeof item === 'object') {
                const keys = Object.keys(item);
                if (keys.length === 1) {
                    const key = keys[0];
                    const value = item[key];

                    // Handle array values as markdown lists
                    if (Array.isArray(value)) {
                        const listItems = value.map(v => `- ${v}`).join('\n');
                        return `${key}:\n${listItems}`;
                    } else {
                        // Non-array values: render inline
                        return `${key}: ${value}`;
                    }
                }
            }
            return item?.toString() || '';
        }

        // Helper function to build combined proficiencies text for form display
        function buildProficienciesText(data) {
            let lines = [];

            function addToLines(dataField) {
                if (Array.isArray(dataField)) {
                    lines = lines.concat(dataField);
                }
            }

            // Add PROFICIENCIES
            addToLines(data['PROFICIENCIES']?.map(stringOfProficienciesEntry));

            // Add horizontal line and SECONDARY PROFICIENCIES if exists
            if (data['SECONDARY PROFICIENCIES'] && Array.isArray(data['SECONDARY PROFICIENCIES']) && data['SECONDARY PROFICIENCIES'].length > 0) {
                addToLines(['----']);
                addToLines(data['SECONDARY PROFICIENCIES'].map(stringOfProficienciesEntry));
            }

            return lines.join('\n');
        }

        // Helper function to convert markdown lists back to objects
        function processMarkdownLists(lines) {
            const processed = [];
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];

                // Check for inline format: "key: value" (creates object with string value)
                const inlineMatch = line.match(/^([^:]+):\s+(.+)$/);
                if (inlineMatch) {
                    const [, key, value] = inlineMatch;
                    const obj = {};
                    obj[key] = value;
                    processed.push(obj);
                    i++;
                }
                // Check if this line ends with a colon (block format for arrays)
                else if (line.match(/:\s*$/)) {
                    const key = line.replace(/:\s*$/, '');
                    const listItems = [];
                    i++; // Move to next line

                    // Collect markdown list items
                    while (i < lines.length) {
                        const nextLine = lines[i];
                        // Markdown list item: 0-3 spaces, then - or *, then at least one space
                        if (nextLine.match(/^ {0,3}[-*] /)) {
                            // Extract the item text after the markdown prefix
                            const item = nextLine.replace(/^ {0,3}[-*] /, '');
                            listItems.push(item);
                            i++;
                        } else {
                            // Not a list item, break out of list processing
                            break;
                        }
                    }

                    // Create object with key and value
                    if (listItems.length > 0) {
                        const obj = {};
                        // Keep arrays as arrays (even single-item arrays)
                        // to preserve original data structure
                        obj[key] = listItems;
                        processed.push(obj);
                    } else {
                        // No list items found, treat as regular line
                        processed.push(line);
                        i++;
                    }
                } else {
                    // Regular line, keep as-is (including strings that contain colons)
                    // Empty strings become null (for YAML spacing)
                    if (line.trim() === '') {
                        processed.push(null);
                    } else {
                        processed.push(line);
                    }
                    i++;
                }
            }

            return processed;
        }

        // Helper to preserve original types (string vs object) in proficiencies
        // Matches parsed items to original items and preserves original type when ambiguous
        function preserveProficiencyTypes(parsedArray, originalArray) {
            return parsedArray.map((parsedItem, index) => {
                if (index >= originalArray.length) return parsedItem;

                const originalItem = originalArray[index];

                // If parsed as object with single key, check if original was a plain string
                if (parsedItem && typeof parsedItem === 'object' && !Array.isArray(parsedItem)) {
                    const keys = Object.keys(parsedItem);
                    if (keys.length === 1 && typeof originalItem === 'string') {
                        // Original was a plain string, reconstruct it
                        const key = keys[0];
                        const value = parsedItem[key];
                        return `${key}: ${value}`;
                    }
                }

                return parsedItem;
            });
        }

        // Helper function to parse proficiencies text and split by horizontal lines
        function parseProficienciesText(text) {
            const data = {};
            if (!text.trim()) {
                data['PROFICIENCIES'] = [];
                return data;
            }

            // Preserve blank lines - only trim whitespace from right side
            const allLines = text.split('\n').map(line => line.trimEnd());
            const horizontalLineIndex = allLines.findIndex(line => /^-{4,}[ \t]*$/.test(line.trim()));

            if (horizontalLineIndex >= 0) {
                // Split by horizontal line
                const mainLines = allLines.slice(0, horizontalLineIndex);
                const otherLines = allLines.slice(horizontalLineIndex + 1);

                if (mainLines.length > 0) data['PROFICIENCIES'] = processMarkdownLists(mainLines);
                if (otherLines.length > 0) data['SECONDARY PROFICIENCIES'] = processMarkdownLists(otherLines);
            } else {
                // No horizontal line, just PROFICIENCIES
                data['PROFICIENCIES'] = processMarkdownLists(allLines);
            }

            return data;
        }

        // Create the proficiencies field handler
        const proficiencies_fields = {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector('#proficiencies-text');
                    if (el) {
                        el.value = buildProficienciesText(data);
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector('#proficiencies-text');
                    const text = el?.value || '';

                    // Parse the text into structured data
                    const parsed = parseProficienciesText(text);

                    // Use passthrough preservation to maintain original types
                    // (distinguishes plain strings from objects with same visual representation)
                    if (originalYamlData) {
                        if (parsed['PROFICIENCIES'] && originalYamlData['PROFICIENCIES']) {
                            parsed['PROFICIENCIES'] = preserveProficiencyTypes(
                                parsed['PROFICIENCIES'],
                                originalYamlData['PROFICIENCIES']
                            );
                        }
                        if (parsed['SECONDARY PROFICIENCIES'] && originalYamlData['SECONDARY PROFICIENCIES']) {
                            parsed['SECONDARY PROFICIENCIES'] = preserveProficiencyTypes(
                                parsed['SECONDARY PROFICIENCIES'],
                                originalYamlData['SECONDARY PROFICIENCIES']
                            );
                        }
                    }

                    // Assign back without wholesale deletion to preserve key order
                    if (Object.prototype.hasOwnProperty.call(parsed, 'PROFICIENCIES')) {
                        data['PROFICIENCIES'] = parsed['PROFICIENCIES'];
                    } else {
                        delete data['PROFICIENCIES'];
                    }

                    if (Object.prototype.hasOwnProperty.call(parsed, 'SECONDARY PROFICIENCIES')) {
                        data['SECONDARY PROFICIENCIES'] = parsed['SECONDARY PROFICIENCIES'];
                    } else {
                        delete data['SECONDARY PROFICIENCIES'];
                    }
                }
            };

        // Font field factory - creates handlers for YAML font fields with radio button groups
        function fontField(yamlKey, buttonGroupName, skipValues = []) {
            return {
                populate(data) {
                    const fontValue = data[yamlKey];
                    let value = 'small'; // Default to small

                    if (fontValue && typeof fontValue === 'string') {
                        // Strip leading backslash if present
                        value = fontValue.replace(/^\\/, '');
                    }

                    // Set the radio button
                    const radio = document.querySelector(`input[name="${buttonGroupName}"][value="${value}"]`);
                    if (radio) {
                        radio.checked = true;
                    }
                },
                capture(data) {
                    const renderOption = document.querySelector(`input[name="${buttonGroupName}"]:checked`)?.value;
                    if (renderOption && !skipValues.includes(renderOption)) {
                        data[yamlKey] = '\\' + renderOption;
                    }
                }
            };
        }

        // Field registry
        const FIELDS = [
            // Character info fields
            textField('CHARACTER NAME', '#character-name'),
            textField('PLAYER NAME', '#player-name'),
            textField('RACE', '#race'),
            textField('BACKGROUND', '#background'),
            textField('ALIGNMENT', '#alignment'),
            textField('EXPERIENCE POINTS', '#experience'),
            textField('AGE', '#age'),
            textField('DESCRIPTION', '#description'),
            textField('MOTIVATION', '#motivation'),

            // Layout control
            radioField('LAYOUT', 'layout'),

            // Checkboxes
            checkboxField('COLOR', '#color', true),
            checkboxField('PREGENERATED', '#pregenerated', false),
            checkboxField('STONES', '#stones', false),
            
            // Class/Level complex logic
            classLevelField(),
            
            // Ability scores
            numberField('STR', '#str'),
            numberField('DEX', '#dex'),
            numberField('CON', '#con'),
            numberField('INT', '#int'),
            numberField('WIS', '#wis'),
            numberField('CHA', '#cha'),
            
            // Combat stats
            textField('PROFICIENCY BONUS', '#proficiency-bonus'),
            textField('MAX HP', '#max-hp'),
            textField('HIT DICE', '#hit-dice'),
            textField('INITIATIVE', '#initiative'),
            textField('SPEED', '#speed'),
            textField('ARMOR CLASS', '#armor-class'),
            textField('SENSES', '#senses'),
            textField('PASSIVE PERCEPTION', '#passive-perception'),
            
            // Currency
            textField('CP', '#cp'),
            textField('SP', '#sp'),
            textField('EP', '#ep'),
            textField('GP', '#gp'),
            textField('PP', '#pp'),
            
            // Array fields
            // Proficiencies with horizontal line splitting
            proficiencies_fields,
            
            // Equipment field factory
            {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const equipmentEl = form.querySelector('#equipment-text');
                    if (equipmentEl && data['EQUIPMENT']) {
                        let equipmentText = '';
                        
                        if (Array.isArray(data['EQUIPMENT'])) {
                            // Handle flat list format
                            const equipList = data['EQUIPMENT'].map(item => item?.toString() || '');
                            equipmentText = equipList.join('\n');
                        } else if (typeof data['EQUIPMENT'] === 'object') {
                            // Handle structured format - unparse it
                            const unparsedLines = unparseEquipmentStructure(data['EQUIPMENT']);
                            equipmentText = unparsedLines.join('\n');
                        } else {
                            // Handle single string (fallback)
                            equipmentText = data['EQUIPMENT'].toString();
                        }
                        
                        equipmentEl.value = equipmentText;
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const equipmentText = form.querySelector('#equipment-text')?.value || '';
                    if (equipmentText.trim()) {
                        const lines = equipmentText.split('\n').map(line => line.trim()).filter(line => line);
                        try {
                            // Parse equipment text into structured format
                            const structuredEquipment = parseEquipmentStrings(lines);

                            // If parsing produced no categories, preserve original format
                            if (Object.keys(structuredEquipment).length === 0) {
                                // Check if original data had equipment and preserve it if unchanged
                                if (originalYamlData && originalYamlData['EQUIPMENT']) {
                                    data['EQUIPMENT'] = originalYamlData['EQUIPMENT'];
                                } else {
                                    // Fall back to simple array format
                                    data['EQUIPMENT'] = lines;
                                }
                            } else {
                                data['EQUIPMENT'] = structuredEquipment;
                            }
                        } catch (error) {
                            // Fallback to list format if parsing fails
                            console.warn('Equipment parsing failed, falling back to list format:', error);
                            data['EQUIPMENT'] = lines;
                        }
                    } else {
                        data['EQUIPMENT'] = {};
                    }
                }
            },
            
            // Dynamic list field factories
            attacksField(),
            nameDescPairs('FEATURES', '.feature-item', addFeature),
            fontField('FEATURES FONT', 'features-render'),
            fontField('MAGIC FONT', 'magic-render', ['separate']),
            magicField()
        ];

        function parseYAMLIntoForm(yamlText) {
            try {
                // Parse for UI data (plain object) and for preserving order (YAML.Document)
                const data = jsyaml.load(yamlText);
                originalYamlText = yamlText;
                try {
                    // May be unavailable if YAML library wasn't loaded
                    originalYamlDoc = (typeof YAML !== 'undefined') ? YAML.parseDocument(yamlText) : null;
                } catch (e) {
                    originalYamlDoc = null;
                }
                if (!data) return;

                // Store original data for passthrough of unknown fields
                originalYamlData = structuredClone(data);

                // Populate all fields using message-passing
                FIELDS.forEach(field => field.populate(data));

                // Update Generate PDF button state since form now has content
                updateGeneratePDFButton();

                // Reset pregens dropdowns and disable buttons when YAML is loaded
                const dropdown3col = document.getElementById('sample-yaml-dropdown-3col');
                const dropdown2col = document.getElementById('sample-yaml-dropdown-2col');
                const button3col = document.getElementById('load-sample-button-3col');
                const button2col = document.getElementById('load-sample-button-2col');
                if (dropdown3col) dropdown3col.value = '';
                if (dropdown2col) dropdown2col.value = '';
                if (button3col) button3col.disabled = true;
                if (button2col) button2col.disabled = true;

            } catch (error) {
                throw new Error('YAML parsing failed: ' + error.message);
            }
        }


        function ifDNDfalse(value) {
            // Following \ifDNDfalse semantics: undefined, empty, "0", or "false" are false
            // Convert to string for comparison to handle both numeric and string values
            if (value === undefined || value === null) return true;
            const valueStr = value.toString().toLowerCase();
            return valueStr === '' || valueStr === '0' || valueStr === 'false';
        }

        function createYAMLContent() {
            const form = document.getElementById('character-form');
            // Build updated data object using existing capture logic
            const updated = originalYamlData ? structuredClone(originalYamlData) : {};
            FIELDS.forEach(field => field.capture(updated));

            // If we have an original document, apply only changes to preserve key order
            if (originalYamlDoc && typeof YAML !== 'undefined') {
                // Recreate a fresh doc from original text to avoid mutating shared state
                const doc = YAML.parseDocument(originalYamlText);
                const changes = collectChanges(originalYamlData || {}, updated || {});
                for (const change of changes) {
                    try {
                        doc.setIn(change.path, change.value);
                    } catch (e) {
                        // Fallback: set at top-level if path fails
                        if (change.path && change.path.length > 0) {
                            const topKey = change.path[0];
                            doc.setIn([topKey], updated[topKey]);
                        }
                    }
                }
                return doc.toString();
            }

            // No original doc (new file): emit fresh YAML with current ordering
            if (typeof YAML !== 'undefined') {
                const outDoc = new YAML.Document();
                outDoc.contents = updated;
                return outDoc.toString();
            }
            // Final fallback: js-yaml
            return jsyaml.dump(updated, { indent: 2, noRefs: true, sortKeys: false });
        }

        function generateYAML() {
            document.getElementById('yaml-output').value = createYAMLContent();
        }

        function copyYAML() {
            const yamlOutput = document.getElementById('yaml-output');
            yamlOutput.select();
            document.execCommand('copy');
            alert('YAML copied to clipboard!');
        }

        function updateDownloadButtonText() {
            const filename = getCharacterFilename();
            const downloadButton = document.querySelector('[onclick="downloadYAML()"]');
            downloadButton.innerHTML = `Download <tt>${filename}</tt>`;
        }
        

        function getCharacterFilename(extension = 'yaml') {
            // Get character name, or fall back to class name if no character name
            const characterName = document.querySelector('#character-name')?.value?.trim() || '';
            const className = document.querySelector('#class')?.value?.trim() || '';
            
            const baseName = characterName || className || 'character';
            
            // Replace spaces (including non-breaking spaces) with regular spaces, then convert to dash
            const cleanName = baseName.toLowerCase()
                .replace(/[\s\u00A0]+/g, '-')  // Replace spaces and non-breaking spaces with dash
                .replace(/[^a-z0-9-]/g, '')   // Remove other non-alphanumeric chars except dash
                .replace(/--+/g, '-')         // Replace multiple dashes with single dash
                .replace(/^-+|-+$/g, '')      // Remove leading/trailing dashes
                || 'character';
            return `${cleanName}.${extension}`;
        }

        function updateDownloadButtonText() {
            const downloadButton = document.querySelector('button[onclick="downloadYAML()"]');
            if (downloadButton) {
                const filename = getCharacterFilename();
                downloadButton.innerHTML = `Download <tt>${filename}</tt>`;
            }
        }

        function downloadYAML() {
            // Generate YAML content using the shared function
            const yamlContent = createYAMLContent();
            
            // Use consistent filename
            const filename = getCharacterFilename();
            
            // Create download
            const blob = new Blob([yamlContent], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        async function generatePDF() {
            try {
                // Generate YAML content using the shared function
                const yamlContent = createYAMLContent();
                
                // Send YAML directly to server (not as parameter)
                const response = await fetch('https://www.cs.tufts.edu/~nr/cgi-bin/render-charsheet.cgi', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/yaml; charset=utf-8',
                    },
                    body: yamlContent
                });
                
                // Get the blob and open it in a new window
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                window.open(url, '_blank');
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                alert(`Failed to generate PDF: ${error.message}. Please check that the server is running and accessible.`);
            }
        }

        // ===============================================
        // Equipment Format Conversion Functions
        // ===============================================
        
        // Category mapping (from Lua charsheet parser)
        const categoryMap = {
            "heavy weapon": "HEAVY WEAPONS",
            "normal weapon": "NORMAL WEAPONS", 
            "light weapon": "LIGHT WEAPONS",
            "shield": "SHIELDS",
            "heavy armor": "HEAVY ARMOR",
            "heavy armour": "HEAVY ARMOR",
            "normal armor": "MEDIUM ARMOR",
            "normal armour": "MEDIUM ARMOR", 
            "medium armor": "MEDIUM ARMOR",
            "medium armour": "MEDIUM ARMOR",
            "light armor": "LIGHT ARMOR",
            "light armour": "LIGHT ARMOR",
            "heavy item": "HEAVY ITEMS",
            "slotted item": "SLOTTED ITEMS",
            "free item": "SMALL ITEMS",
            "small item": "SMALL ITEMS",
            "stored": "STORED ITEMS",
            "stored item": "STORED ITEMS",
        };

        function stripS(s) {
            return s.endsWith('s') ? s.slice(0, -1) : s;
        }

        function getCategory(s) {
            return categoryMap[stripS(s.toLowerCase())];
        }

        function capitalize(s) {
            return s.replace(/\b\w+/g, word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            );
        }

        function formatCategoryName(category) {
            return capitalize(category.toLowerCase().replace(/s$/, ''));
        }

        // Equipment format detection
        function isStringListWithCategories(equipmentData) {
            if (!Array.isArray(equipmentData) || equipmentData.length === 0) {
                return false;
            }
            if (typeof equipmentData[0] !== 'string') {
                return false;
            }
            // Check if any item has category syntax
            return equipmentData.some(item => 
                typeof item === 'string' && (item.includes(':') || item.startsWith('-'))
            );
        }

        function isStructuredObject(equipmentData) {
            if (typeof equipmentData !== 'object' || Array.isArray(equipmentData) || !equipmentData) {
                return false;
            }
            return Object.keys(equipmentData).length > 0;
        }

        // Parse equipment strings (port of Lua function)
        function parseEquipmentStrings(lines) {
            const equipment = {};
            let i = 0;

            function add(category, item) {
                if (!equipment[category]) {
                    equipment[category] = [];
                }
                equipment[category].push(item);
            }

            while (i < lines.length) {
                const line = lines[i].trim();
                const blockHeader = line.match(/^(.+):$/);
                
                if (line === "") {
                    // Skip empty lines
                    i++;
                } else if (blockHeader && getCategory(blockHeader[1])) {
                    // Block format category header: "CATEGORY:"
                    const cat = getCategory(blockHeader[1]);
                    equipment[cat] = equipment[cat] || []; // populate even if no items follow
                    i++;
                    while (i < lines.length && /^\s*-\s/.test(lines[i])) {
                        const item = lines[i].replace(/^\s*-\s+/, "").trim();
                        add(cat, item);
                        i++;
                    }
                } else if (blockHeader) {
                    console.warn(`Unknown equipment category "${blockHeader[1]}"`);
                    i++;
                } else if (/^\S.*:/.test(line)) {
                    // Inline format: "CATEGORY: Item Name"
                    const match = line.match(/^([^:]+?):\s*(.*)$/);
                    if (match) {
                        const [, cat, item] = match;
                        if (getCategory(cat.trim())) {
                            add(getCategory(cat.trim()), item.trim());
                        } else {
                            console.warn(`Unknown equipment category "${cat}" in line "${line}"`);
                        }
                    }
                    i++;
                } else {
                    // Heuristic equipment parser disabled per user request
                    console.warn(`Unknown equipment format in line "${line}"`);
                    i++;
                }
            }
            return equipment;
        }

        // Convert structured equipment back to string list format
        function unparseEquipmentStructure(structuredEquipment) {
            const lines = [];
            
            for (const [category, items] of Object.entries(structuredEquipment)) {
                if (Array.isArray(items)) {
                    if (items.length === 1) {
                        // Single item: use inline format
                        const formattedCategory = formatCategoryName(category);
                        lines.push(`${formattedCategory}: ${items[0]}`);
                    } else {
                        // Multiple items or empty: use block format
                        const formattedCategory = formatCategoryName(category);
                        lines.push(`${formattedCategory}s:`);
                        items.forEach(item => {
                            lines.push(`- ${item}`);
                        });
                    }
                }
            }
            
            return lines;
        }

        // Deep equality check for objects/arrays
        function deepEqual(obj1, obj2) {
            if (obj1 === obj2) return true;
            
            if (obj1 == null || obj2 == null) return obj1 === obj2;
            
            if (typeof obj1 !== typeof obj2) return false;
            
            if (typeof obj1 !== 'object') return obj1 === obj2;
            
            if (Array.isArray(obj1) !== Array.isArray(obj2)) return false;
            
            const keys1 = Object.keys(obj1);
            const keys2 = Object.keys(obj2);
            
            if (keys1.length !== keys2.length) return false;
            
            return keys1.every(key => deepEqual(obj1[key], obj2[key]));
        }

        // Convert any equipment format to unified structured format
        function equipmentToStructured(equipmentData) {
            if (isStringListWithCategories(equipmentData)) {
                return parseEquipmentStrings(equipmentData);
            } else if (isStructuredObject(equipmentData)) {
                return equipmentData; // already in structured format
            } else if (Array.isArray(equipmentData) && equipmentData.length > 0) {
                // Traditional string list - put everything in heuristic category
                return { 'SLOTTED ITEMS': equipmentData };
            } else {
                return {}; // empty equipment
            }
        }

        // Round-trip validation function
        function validateEquipmentRoundTrip(structuredEquipment) {
            // Skip validation for empty structures
            if (!structuredEquipment || Object.keys(structuredEquipment).length === 0) {
                return structuredEquipment;
            }
            
            // Unparse to string list format
            const unparsedLines = unparseEquipmentStructure(structuredEquipment);
            
            // Parse it back
            const reparsedStructure = parseEquipmentStrings(unparsedLines);
            
            // Compare with original
            if (!deepEqual(structuredEquipment, reparsedStructure)) {
                const error = {
                    message: 'Equipment round-trip validation failed!',
                    original: structuredEquipment,
                    unparsedLines: unparsedLines,
                    reparsed: reparsedStructure
                };
                console.error(error);
                throw new Error(error.message + '\nCheck console for details.');
            }
            
            return structuredEquipment;
        }

        // ===============================================
        // Equipment UI Functions
        // ===============================================
        
        function convertEquipmentToStructured() {
            const equipmentText = document.getElementById('equipment-text').value;
            if (!equipmentText.trim()) {
                alert('No equipment text to convert!');
                return;
            }
            
            try {
                const lines = equipmentText.split('\n');
                const structured = equipmentToStructured(lines);
                const validated = validateEquipmentRoundTrip(structured);
                
                // Display result in a nice format
                let display = 'Structured Equipment:\n\n';
                for (const [category, items] of Object.entries(validated)) {
                    display += `${category}:\n`;
                    if (Array.isArray(items)) {
                        items.forEach(item => display += `  - ${item}\n`);
                    }
                    display += '\n';
                }
                
                alert(display);
                
            } catch (error) {
                alert(`Error converting equipment: ${error.message}`);
            }
        }
        
        function convertStructuredToLines() {
            const equipmentText = document.getElementById('equipment-text').value;
            if (!equipmentText.trim()) {
                alert('No equipment text to convert!');
                return;
            }
            
            try {
                const lines = equipmentText.split('\n');
                const structured = equipmentToStructured(lines);
                const validated = validateEquipmentRoundTrip(structured);
                const converted = unparseEquipmentStructure(validated);
                
                // Update the textarea with converted format
                document.getElementById('equipment-text').value = converted.join('\n');
                
                alert('Equipment converted to categorized format!');
                
            } catch (error) {
                alert(`Error converting equipment: ${error.message}`);
            }
        }

        // Test function for the equipment parsing
        function testEquipmentParsing() {
            const testCases = [
                {
                    name: "Single items",
                    input: {
                        "HEAVY WEAPONS": ["Maul"],
                        "SHIELDS": ["Shield"],
                        "SLOTTED ITEMS": ["Backpack"]
                    }
                },
                {
                    name: "Multiple items and empty",
                    input: {
                        "SLOTTED ITEMS": ["Backpack", "Bedroll", "Rations"],
                        "SMALL ITEMS": [],
                        "NORMAL WEAPONS": ["Longsword"]
                    }
                },
                {
                    name: "String list with categories",
                    input: [
                        "Heavy weapon: Greatsword",
                        "Light armor: Leather armor",
                        "Slotted items:",
                        "- Backpack",
                        "- Rations (5 days)",
                        "Small items:"
                    ]
                },
                {
                    name: "Traditional flat list", 
                    input: ["Leather armor", "Shortsword", "Backpack", "Bedroll"]
                }
            ];

            let results = 'Equipment Parsing Test Results:\n\n';
            let allPassed = true;

            testCases.forEach(testCase => {
                try {
                    const structured = equipmentToStructured(testCase.input);
                    const validated = validateEquipmentRoundTrip(structured);
                    const unparsed = unparseEquipmentStructure(validated);
                    
                    results += `✅ ${testCase.name}: PASSED\n`;
                    results += `   Unparsed format:\n`;
                    unparsed.forEach(line => results += `     ${line}\n`);
                    results += '\n';
                    
                } catch (error) {
                    results += `❌ ${testCase.name}: FAILED\n`;
                    results += `   Error: ${error.message}\n\n`;
                    allPassed = false;
                }
            });
            
            results += allPassed ? '\n🎉 All tests PASSED!' : '\n⚠️  Some tests FAILED!';
            
            // Show results in a popup and log to console
            alert(results);
            console.log('Equipment parsing test results:', results);
        }

    </script>
</body>
</html>
