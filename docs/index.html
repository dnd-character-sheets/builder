<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Character Sheet Creator</title>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <link rel="stylesheet" href="charsheet.css">
</head>
<body>
    <h1>D&D Character Sheet Creator</h1>
    <div style="text-align: center; font-size: 0.8em; color: #666; margin-bottom: 1em;">
        Version: fennel
    </div>
    
    <div style="text-align: center; margin: 1em 0; padding: 1em; background-color: #f4f4f4; border-radius: 4px;">
        <div style="margin-bottom: 0.5em;">
            <input type="file" id="yaml-file" accept=".yaml,.yml" style="display: none;" onchange="loadYAMLFile(event)">
            <button type="button" class="add-button" onclick="document.getElementById('yaml-file').click()">Load YAML File</button>
            <button type="button" class="add-button" onclick="downloadYAML()">Download <tt>character.yaml</tt></button>
        </div>
        <div style="margin-bottom: 0.5em;">
            <button type="button" class="generate-button" onclick="generatePDF()">Generate PDF</button>
            <div style="display: inline-block; margin-left: 1em; vertical-align: top; text-align: left;">
                <div style="margin-bottom: 0.3em;">
                    <label>
                        <input type="radio" name="layout" value="silverpine" checked>
                        Two unequal columns (Silverpine Watch style)
                    </label>
                </div>
                <div style="margin-bottom: 0.3em;">
                    <label>
                        <input type="radio" name="layout" value="3col">
                        Three equal columns
                    </label>
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="color" checked>
                        Use colored backgrounds
                    </label>
                </div>
                <div>
                    <label>
                        <input type="checkbox" id="pregenerated" name="pregenerated">
                        Label as pregenerated character
                    </label>
                </div>  
                <div>
                    <label>
                        <input type="checkbox" id="stones" name="stones">
                        Organize equipment by weight, using
                        <a href="https://thealexandrian.net/wordpress/46824/roleplaying-games/5e-encumbrance-by-stone">
                        Alexandrian stones</a>
                    </label>

            </div>
        </div>
    </div>

    <!-- Sample YAML Section -->
    <div style="text-align: left; margin: 1.5em 0; padding: 1em; background-color: #f4f4f4; border-radius: 4px;">
        <div style="margin-bottom: 0.5em;">
            <select id="sample-yaml-dropdown" style="padding: 0.3em;">
                <option value="">Try a pregenerated character</option>
            </select>
            <button type="button" id="load-sample-button" class="add-button" onclick="loadSampleYAML()" style="margin-right: 0.5em;" disabled>Load this character</button>
        </div>
    </div>

    <div id="status-bar" style="text-align: center; margin: 0.5em 0; font-size: 0.9em; color: #666; min-height: 1.2em;">
        <strong>Tip:</strong> Use <kbd>Ctrl+Enter</kbd> (or <kbd>Cmd+Enter</kbd> on Mac) to quickly add items when focused in Attacks, Spells, or Features sections
    </div>
    
    <form id="character-form">
        <!-- Character Info Section -->
        <div class="section playername">
            <h2>Character Info</h2>
            <div class="field-row">
                <div class="field wide">
                    <label for="character-name">Character Name</label>
                    <input type="text" id="character-name" name="character-name">
                </div>
                <div class="field wide">
                    <label for="player-name">Player Name</label>
                    <input type="text" id="player-name" name="player-name">
                </div>
            </div>
            <div class="field-row">
                <div class="field">
                    <label for="age">Age</label>
                    <input type="text" id="age" name="age" placeholder="e.g., young adult">
                </div>
            </div>
            <div class="field-row">
                <div class="field">
                    <label for="description">Physical Description</label>
                    <textarea id="description" name="description" rows="3" placeholder="e.g., tall, dark hair, piercing blue eyes"></textarea>
                </div>
            </div>
            <div class="field-row">
                <div class="field">
                    <label for="class">Class</label>
                    <select id="class" name="class">
                        <option value="">Select Class</option>
                        <option value="Barbarian">Barbarian</option>
                        <option value="Bard">Bard</option>
                        <option value="Cleric">Cleric</option>
                        <option value="Druid">Druid</option>
                        <option value="Fighter">Fighter</option>
                        <option value="Monk">Monk</option>
                        <option value="Paladin">Paladin</option>
                        <option value="Ranger">Ranger</option>
                        <option value="Rogue">Rogue</option>
                        <option value="Sorcerer">Sorcerer</option>
                        <option value="Warlock">Warlock</option>
                        <option value="Wizard">Wizard</option>
                    </select>
                </div>
                <div class="field">
                    <label for="level">Level</label>
                    <input type="number" id="level" name="level" min="1" max="20">
                </div>
                <div class="field">
                    <label for="specialty">Specialty</label>
                    <input type="text" id="specialty" name="specialty" placeholder="e.g., Life Domain, Champion">
                </div>
                <div class="field">
                    <label for="race">Race</label>
                    <input type="text" id="race" name="race">
                </div>
            </div>
            <div class="field-row">
                <div class="field wide">
                    <label for="background">Background</label>
                    <input type="text" id="background" name="background">
                </div>
                <div class="field">
                    <label for="alignment">Alignment</label>
                    <input type="text" id="alignment" name="alignment">
                </div>
                <div class="field">
                    <label for="experience">Experience Points</label>
                    <input type="text" id="experience" name="experience">
                </div>
            </div>
            <div class="field-group">
                <label for="motivation">Motivation</label>
                <input type="text" id="motivation" name="motivation" placeholder="Character's personal motivation" style="width: 100%;">
            </div>
        </div>

        <!-- Stats Section -->
        <div class="section stats">
            <h2>Ability Scores</h2>
            <div class="ability-scores">
                <div class="field">
                    <label for="str">Strength</label>
                    <input type="number" id="str" name="str" min="1" max="30">
                </div>
                <div class="field">
                    <label for="dex">Dexterity</label>
                    <input type="number" id="dex" name="dex" min="1" max="30">
                </div>
                <div class="field">
                    <label for="con">Constitution</label>
                    <input type="number" id="con" name="con" min="1" max="30">
                </div>
                <div class="field">
                    <label for="int">Intelligence</label>
                    <input type="number" id="int" name="int" min="1" max="30">
                </div>
                <div class="field">
                    <label for="wis">Wisdom</label>
                    <input type="number" id="wis" name="wis" min="1" max="30">
                </div>
                <div class="field">
                    <label for="cha">Charisma</label>
                    <input type="number" id="cha" name="cha" min="1" max="30">
                </div>
            </div>
        </div>

        <!-- Combat Stats Section -->
        <div class="section hpetc">
            <h2>Combat Stats</h2>
            <div class="field-row">
                <div class="field">
                    <label for="max-hp">Max HP</label>
                    <input type="number" id="max-hp" name="max-hp" min="1">
                </div>
                <div class="field">
                    <label for="hit-dice">Hit Die</label>
                    <select id="hit-dice" name="hit-dice">
                        <option value="">Select</option>
                        <option value="d6">d6</option>
                        <option value="d8">d8</option>
                        <option value="d10">d10</option>
                        <option value="d12">d12</option>
                    </select>
                </div>
            </div>
            <div class="field-row">
                <div class="field">
                    <label for="initiative">Initiative</label>
                    <input type="text" id="initiative" name="initiative" placeholder="+1">
                </div>
                <div class="field">
                    <label for="speed">Speed</label>
                    <input type="text" id="speed" name="speed" placeholder="30">
                </div>
                <div class="field">
                    <label for="armor-class">Armor Class</label>
                    <input type="number" id="armor-class" name="armor-class" min="1">
                </div>
            </div>
            <div class="field-row">
                <div class="field wide">
                    <label for="senses">Senses</label>
                    <input type="text" id="senses" name="senses" placeholder="Darkvision 60 ft.">
                </div>
                <div class="field">
                    <label for="passive-perception">Passive Perception</label>
                    <input type="number" id="passive-perception" name="passive-perception" min="1">
                </div>
            </div>
        </div>

        <!-- Proficiencies Section -->
        <div class="section proficiencies">
            <h2>Proficiencies</h2>
            <div class="field-group" style="display: flex; align-items: center; gap: 0.5em; margin-bottom: 1em;">
                <span>Proficiency Bonus +</span>
                <input type="number" id="proficiency-bonus" name="proficiency-bonus" min="2" max="6" style="width: 2em; text-align: center;" placeholder="2">
            </div>
            <div class="field-group">
                <p>Enter one proficiency per line. Include skill, language, and equipment proficiencies. Leave a blank line between categories.</p>
                <textarea id="proficiencies-text" name="proficiencies-text" rows="8" placeholder="Athletics&#10;Medicine&#10;Nature&#10;&#10;Common&#10;Orcish&#10;&#10;Light Armor&#10;Shield&#10;Simple Weapons" style="width: 100%; box-sizing: border-box;"></textarea>
            </div>
        </div>

        <!-- Attacks Section -->
        <div class="section attacks">
            <h2>Attacks</h2>
            <div id="attacks-list">
                <!-- Dynamic attacks will be added here -->
            </div>
            <button type="button" class="add-button" onclick="addAttack()">Add Attack</button>
        </div>

        <!-- Magic Section -->
        <div class="section magic" id="magic-section">
            <h2 id="magic-header" onclick="toggleMagic()" style="cursor: pointer;">Magic (click to open)</h2>
            <div id="magic-content" style="display: none;">
                <div class="field-group" style="margin-bottom: 1em;">
                    <span>Render:</span>
                    <div style="margin-top: 0.5em;">
                        <label style="display: block; margin-bottom: 0.3em; font-weight: normal;">
                            <input type="radio" name="magic-render" value="normalsize"> at normal size
                        </label>
                        <label style="display: block; margin-bottom: 0.3em; font-weight: normal;">
                            <input type="radio" name="magic-render" value="small" checked> in a smaller font
                        </label>
                        <label style="display: block; margin-bottom: 0.3em; font-weight: normal;">
                            <input type="radio" name="magic-render" value="footnotesize"> in an even smaller font
                        </label>
<!--
                        <label style="display: block; margin-bottom: 0.3em; font-weight: normal;">
                            <input type="radio" name="magic-render" value="separate"> on a page of its own
-->
                        </label>
                    </div>
                </div>
                <div id="magic-levels">
                    <!-- Spell levels are added dynamically as needed -->
                </div>
                <div id="next-level-button-container">
                    <!-- Next level button will appear here -->
                </div>
            </div>
        </div>

        <!-- Features Section -->
        <div class="section features">
            <h2>Features</h2>
            <div class="field-group" style="margin-bottom: 1em;">
                <span>Render:</span>
                <div style="margin-top: 0.5em;">
                    <label style="display: block; margin-bottom: 0.3em; font-weight: normal;">
                        <input type="radio" name="features-render" value="normalsize"> at normal size
                    </label>
                    <label style="display: block; margin-bottom: 0.3em; font-weight: normal;">
                        <input type="radio" name="features-render" value="small" checked> in a smaller font
                    </label>
                    <label style="display: block; margin-bottom: 0.3em; font-weight: normal;">
                        <input type="radio" name="features-render" value="footnotesize"> in an even smaller font
                    </label>
                </div>
            </div>
            <div id="features-list">
                <!-- Dynamic features will be added here -->
            </div>
            <button type="button" class="add-button" onclick="addFeature()">Add Feature</button>
        </div>

        <!-- Equipment Section -->
        <div class="section equipment">
            <h2>Equipment</h2>
            <div class="field-group">
                <p>Enter one equipment item per line. Or you scan specify categories:</p>
                <ul style="font-size: 0.9em; margin: 0.5em 0; color: #666;">
                    <li><code>Heavy weapon: Greatsword</code> (single item)</li>
                    <li><code>Slotted items:</code> followed by <code>- Backpack</code>, <code>- Rations</code> (multiple items)</li>
                </ul>
                <textarea id="equipment-text" name="equipment-text" rows="6" placeholder="Scale Mail Armor&#10;Shield (+2 AC)&#10;Backpack&#10;Bedroll&#10;Mess Kit&#10;Torches (10)&#10;Rations (10)&#10;Waterskin" style="width: 100%; box-sizing: border-box;"></textarea>
                
                <div style="margin-top: 0.5em; display: flex; gap: 0.5em; flex-wrap: wrap;">
                    <button type="button" class="add-button" onclick="convertStructuredToLines()" title="Convert your equipment list to the new categorized format">
                        üìù Categorize Equipment
                    </button>
                    <button type="button" class="add-button" onclick="convertEquipmentToStructured()" title="Show how your equipment would be parsed into categories">
                        üîç Preview Categories
                    </button>
                    <button type="button" class="add-button" onclick="testEquipmentParsing()" title="Run tests to verify the equipment parsing system works correctly">
                        üß™ Test Parser
                    </button>
                </div>
            </div>
            
            <h3>Currency</h3>
            <div class="currency-fields">
                <div class="field">
                    <label for="cp">Copper (CP)</label>
                    <input type="text" id="cp" name="cp">
                </div>
                <div class="field">
                    <label for="sp">Silver (SP)</label>
                    <input type="text" id="sp" name="sp">
                </div>
                <div class="field" style="display: none;">
                    <label for="ep">Electrum (EP)</label>
                    <input type="text" id="ep" name="ep">
                </div>
                <div class="field">
                    <label for="gp">Gold (GP)</label>
                    <input type="text" id="gp" name="gp">
                </div>
                <div class="field">
                    <label for="pp">Platinum (PP)</label>
                    <input type="text" id="pp" name="pp">
                </div>
            </div>
        </div>

    </form>


    <script>
        // Embedded YAML data - will be populated by insert-pregen-yamls script
        const EMBEDDED_YAMLS = [
    {
        origin: "Fighter by NoxAeternus (best at 3 columns)",
        content: "\"CHARACTER NAME\": \"\"\n\"CLASS & LEVEL\": Fighter 1\n\"BACKGROUND\": Soldier\n\"PLAYER NAME\": \"\"\n\"RACE\": Mountain Dwarf\n\"ALIGNMENT\": \"\"\n\"EXPERIENCE POINTS\": \"\"\n\n# ability scores ‚Äî only the score in the lower oval\nSTR: 17\nDEX: 14\nCON: 14\nINT: 8\nWIS: 14\nCHA: 10\n\n\"PROFICIENCY BONUS\": +2\n\"PASSIVE PERCEPTION\": 14\n\"MAX HP\": 22\n\"CURRENT HIT POINTS\": \"\"\n\"INITIATIVE\": \"+2\"\n\"SPEED\": 25\n\"ARMOR CLASS\": 18\n\"SENSES\": Darkvision 60¬†ft.\n\"HIT DICE\": d10\n\n# coin totals (none listed on the sheet)\nCP: \"\"\nSP: \"\"\nEP: \"\"\nGP: \"\"\nPP: \"\"\n\nMAIN PROFICIENCIES:\n  # Skills\n  - Skills:\n      - Athletics\n      - Intimidation\n      - Perception\n#      - Stonecunning (+4) # seems bogus\n      - Survival\n  - \n  - Tools:   # Tools & vehicles\n    - Gaming Set (Dice)\n    - Vehicles (Land)\n    - Smith‚Äôs Tools\n  - \n  - Notes:\n      - Advantage on saves against poison\n\nOTHER PROFICIENCIES:\n  # Languages, armor, weapons\n  - Languages: Common, Dwarvish\n  - Armor: All, Shields\n  - Weapons: Simple, Martial\n\nEQUIPMENT:\n  - Chainmail Armor\n  - Shield (+2 AC)\n  - Smith‚Äôs Tools\n  - Backpack\n  - Crowbar\n  - Hammer\n  - Tinderbox\n  - Torches (10)\n  - Pitons (10)\n  - Rations (10)\n  - Waterskin\n  - 50 ft. Rope\n\nATTACKS:\n  - NAME: Longsword\n    ATTACK: \"+5\"\n    DAMAGE: 1d8+3\n    TYPE: slashing\n    RANGE: 5 ft.\n    NOTES: >-\n        If wielded with two hands you cannot use your shield (‚Äì2¬†AC)\n        but you deal +2¬†damage.\n  - NAME: Dwarven Long Axe\n    ATTACK: \"+5\"\n    DAMAGE: 1d8+3\n    TYPE: slashing\n    RANGE: 20/60 ft.\n    NOTES: One-handed melee weapon that can be thrown.\n\nFEATURES:\n  - name: Military Rank\n    description: Advantage on checks in social situations that involve NPCs with military experience.\n  - name: Dwarven Resilience\n    description: Advantage on saving throws against poison and resistance to poison damage (\\textbf{take half damage}).\n  - name: Stonecunning\n    description: +1 when examining stonework (History checks related to the origin of stonework).\n  - name: Protection Fighting Style\n    description: When a creature within 5 ft. of you attacks, you may use your reaction to impose disadvantage on its attack roll if you are wielding a shield.\n  - name: Second Wind\n    description: Once per long rest, use a bonus action to heal yourself for 1d10 + 1 HP.\n\n\"SUGGESTED MOTIVATIONS\":\n  - Obey duty.\n  - Amass wealth.\n  - Prove mettle.\n\n\"SUGGESTED NAMES\":\n  - Hovald\n  - Harva\n\nPREGENERATED: true\nSHEET ORIGIN: Fighter by NoxAeternus (best at 3 columns)\nLAYOUT: 3col\n"
    },
    {
        origin: "Barbarian by NoxAeternus (best at 3 columns)",
        content: "\"CHARACTER NAME\": \"\"\n\"CLASS & LEVEL\": Barbarian 1\n\"BACKGROUND\": Hermit (Custom)\n\"PLAYER NAME\": \"\"\n\"RACE\": Half-Orc\n\"ALIGNMENT\": \"\"\n\"EXPERIENCE POINTS\": \"\"\nPREGENERATED: true\n\n# ability scores ‚Äî only the score in the lower oval\nSTR: 17\nDEX: 14\nCON: 14\nINT: 8\nWIS: 12\nCHA: 10\n\n\"PROFICIENCY BONUS\": +2\n\"PASSIVE PERCEPTION\": 13\n\"MAX HP\": 23\n\"CURRENT HIT POINTS\": \"\"\n\"INITIATIVE\": \"+2\"\n\"SPEED\": 30\n\"ARMOR CLASS\": 14\n\"SENSES\": Darkvision 60 ft.\n\"HIT DICE\": d12\n\n# coin totals\nCP: \"\"\nSP: \"\"\nEP: \"\"\nGP: 5\nPP: \"\"\n\nMAIN PROFICIENCIES:\n  - Skills:\n      - Animal Handling\n      - Athletics\n      - Perception\n      - Intimidation\n      - Survival\n  - proficiencies_skip: true\n  - Tools: \n      - Herbalism Kit\nOTHER PROFICIENCIES:\n  - \"Languages: Common, Orcish, Dwarvish\"\n  - \"Armor: Light, Medium, Shields\"\n  - Weapons: Simple, Martial\nEQUIPMENT:\n  - Common Clothes\n  - Winter Blanket\n  - Herbalism Kit\n  - Backpack\n  - Bedroll\n  - Mess Kit\n  - Tinderbox\n  - Torches (10)\n  - Rations (10)\n  - Waterskin\n\nATTACKS:\n  - NAME: Greataxe\n    ATTACK: \"+5\"\n    DAMAGE: 1d12+3\n    TYPE: slashing\n    RANGE: 5 ft.\n  - NAME: Hand Axe\n    ATTACK: \"+5\"\n    DAMAGE: 1d6+3\n    TYPE: slashing\n    RANGE: 20/60 ft.\n    NOTES: Can be thrown.\n    AMMO TYPE: axes\n    AMMO COUNT: 2\n\nFEATURES:\n  - name: Hermit Discovery\n    description: With an action you can use an Herbalism Kit, destroying it in the process, to stabilize one target.\n  - name: Darkvision 60 ft.\n    description: You can see in dim light as if it were bright and in darkness as if it were dim (disadvantage on Perception in darkness).\n  - name: Relentless Endurance\n    description: Once per long rest, when you are reduced to 0 HP, you instead stay at 1 HP.\n  - name: Savage Attacks\n    description: When you score a critical hit with a melee attack, add one extra weapon damage die to the total.\n  - name: Unarmored Defense\n    description: If you wear no armor, your AC = 10 + Dex + Con.\n  - name: Rage\n    description: |\n       Start/stop as a bonus action. Lasts 1 minute or until you are\n       unconscious or fail to attack or take damage for 1 turn. Can‚Äôt\n       concentrate. \\hskip 2em \\emph{While raging:} ‚Ä¢¬†Advantage on Str checks & saves. \n       ‚Ä¢¬†Melee Str attacks deal +2 damage. ‚Ä¢¬†You take half damage from\n       bludgeoning, piercing, and slashing damage. ‚Ä¢¬†At 1st level you\n       can rage 2 times per long rest.\n\n\"SUGGESTED MOTIVATIONS\":\n  - Earn glory.\n  - Satisfy wanderlust.\n  - Prove mettle.\n\n\"SUGGESTED NAMES\":\n  - Kesk or Kethra\n\nSHEET ORIGIN: Barbarian by NoxAeternus (best at 3 columns)\nLAYOUT: 3col\n"
    },
    {
        origin: "Cleric by NoxAeternus (best at 3 columns)",
        content: "\"CHARACTER NAME\": \"\"\n\"CLASS & LEVEL\": Cleric (Life Domain) 1\n\"BACKGROUND\": Acolyte\n\"PLAYER NAME\": \"\"\n\"RACE\": Human\n\"ALIGNMENT\": \"\"\n\"EXPERIENCE POINTS\": \"\"\n\n# ability scores ‚Äî only the score in the lower oval\nSTR: 9\nDEX: 15\nCON: 14\nINT: 11\nWIS: 16\nCHA: 13\n\n\"PROFICIENCY BONUS\": +2\n\"PASSIVE PERCEPTION\": 13\n\"MAX HP\": 17\n\"CURRENT HIT POINTS\": \"\"\n\"INITIATIVE\": \"+2\"\n\"SPEED\": 30\n\"ARMOR CLASS\": 18\n\"SENSES\": \"\"\n\"HIT DICE\": d8\n\n# coin totals\nCP: \"\"\nSP: \"\"\nEP: \"\"\nGP: 10\nPP: \"\"\n\nPROFICIENCIES:\n  - Skills:\n    - Insight\n    - Medicine\n    - Persuasion\n    - Religion\n    - Nature\nOTHER PROFICIENCIES:\n  - Languages: Common, Celestial, Abyssal, Infernal\n  - Armor: All, Shields\n  - Weapons: Simple\n\nEQUIPMENT:\n  - Cleric's Vestments\n  - Holy Symbol\n  - Scale Mail Armor\n  - Shield (+2 AC)\n  - Backpack\n  - Blanket\n  - Candles (10)\n  - Incense Sticks (2)\n  - Censer\n  - Tinderbox\n  - Rations (10)\n  - Waterskin\n\nATTACKS:\n  - NAME: Mace\n    ATTACK: \"+1\"\n    DAMAGE: 1d6-1\n    TYPE: bludgeoning\n    RANGE: 5 ft.\n    NOTES: \"\"\n  - NAME: Light crossbow\n    ATTACK: \"+4\"\n    DAMAGE: 1d8+2\n    TYPE: piercing\n    RANGE: 80/320 ft.\n    AMMO TYPE: \"bolts\"\n    AMMO COUNT: 20\n    NOTES: \"\"\n  - NAME: Guiding Bolt\n    ATTACK: \"+5\"\n    DAMAGE: 4d6\n    TYPE: radiant\n    RANGE: 120 ft\n    NOTES: >-\n      If it hits, the next attack against that target has\n      Advantage. \\textbf{Using this attack consumes one of your two daily spell slots}.\n\nMAGIC FONT: \\small\nMAGIC:\n  - level: 0                             # CANTRIPS\n  - name: Light\n    description: An object you touch sheds bright light in a 20-ft radius and dim light for an additional 20 ft for 1 hour.\n  - name: Mending\n    description: Repair a non-magical object you can touch, restoring it to full working order.\n  - name: Minor Blessing\n    description: One touched creature gains +2 to attack rolls until the end of your next turn.\n  - level : { number: 1, slots : 2 }                             # 1st LEVEL\n  - name: Bless\n    description: Up to three allies within 30 ft gain +1d4 to attacks and saves for 1 minute while you maintain concentration.\n  - name: Cure Wounds\n    description: A touched creature regains 1d8+3¬†HP.\n  - name: Guiding Bolt\n    description: Ranged spell attack (+5), 120 ft, 4d6 radiant damage; next attack against the target has advantage; consumes a spell slot.\n  - name: Healing Word\n    description: Bonus action; a creature within 60 ft regains 1d4+3 HP.\n  - name: Sanctuary\n    description: Bonus action; a creature within 30 ft is warded for 1 minute. Foes must pass a DC 13 Wis save or choose a new target or lose the attack/spell.\n  - name: Shield of Faith\n    description: Bonus action; a creature within 60 ft gains +2 AC for 10 minutes while you maintain concentration.\n\nFEATURES:\n  - name: Shelter of the Faithful\n    description: As long as you are on good terms with your temple, friendly temples will give you and your party free lodging and care.\n  - name: Disciple of Life\n    description: Your healing spells restore an additional 2 HP + the spell‚Äôs level.\n#  - name: Channel Divinity Unavailable (1st-level cleric)\n#    description: Feature available at 2nd level; not yet gained.\n#  - name: Spellcasting\n#    description: You can cast cleric spells. You prepare Wisdom mod (+3) + level (1) = 4 spells and recover all slots after a long rest.\n\n\"SUGGESTED MOTIVATIONS\":\n  - Earn recognition.\n  - Do good.\n  - Help others.\n\n\"SUGGESTED NAMES\":\n  - Auros or Aurenia\n\nPREGENERATED: true\nSHEET ORIGIN: Cleric by NoxAeternus (best at 3 columns)\nLAYOUT: 3col\n"
    },
    {
        origin: "Paladin by NoxAeternus (best at 3 columns)",
        content: "\"CHARACTER NAME\": \"\"\n\"CLASS & LEVEL\": Paladin 1\n\"BACKGROUND\": Soldier\n\"PLAYER NAME\": \"\"\n\"RACE\": Dragonborn (Bronze)\n\"ALIGNMENT\": \"\"\n\"EXPERIENCE POINTS\": \"\"\n\n# ability scores ‚Äî only the score in the lower oval\nSTR: 16\nDEX: 8\nCON: 13\nINT: 10\nWIS: 12\nCHA: 16\n\n\"PROFICIENCY BONUS\": +2\n\"PASSIVE PERCEPTION\": 11\n\"MAX HP\": 18\n\"CURRENT HIT POINTS\": \"\"\n\"INITIATIVE\": \"-1\"\n\"SPEED\": 30\n\"ARMOR CLASS\": 16\n\"SENSES\": \"\"\n\"HIT DICE\": d10\n\n# coin totals\nCP: \"\"\nSP: \"\"\nEP: \"\"\nGP: 10\nPP: \"\"\n\nPROFICIENCIES:\n  - Skills:\n      - Athletics\n      - Intimidation\n      - Persuasion\n      - Religion\n  -\n  - Tools:\n    - Gaming Set (Dice)\n    - Vehicles (Land)\n  -\n  - Notes: \n    - Disadvantage on Stealth while wearing chain-mail armor\n\nOTHER PROFICIENCIES:\n  - Languages: Common, Draconic\n  - Armor: All, Shields\n  - Weapons: Simple, Martial\n\nEQUIPMENT:\n  - Common Clothes\n  - Chain Mail Armor\n  - Holy Symbol\n  - Backpack\n  - Bedroll\n  - Mess Kit\n  - Tinderbox\n  - Torches (10)\n  - Rations (10)\n  - Waterskin\n  - 50 ft. Rope\n\nATTACKS:\n  - NAME: Greatsword\n    ATTACK: \"+5\"\n    DAMAGE: 2d6+3\n    TYPE: slashing\n    RANGE: 5 ft.\n    NOTES: \"\"\n  - NAME: Javelin\n    ATTACK: \"+1\"\n    DAMAGE: 1d6-1\n    TYPE: piercing\n    RANGE: 30/120 ft.\n    AMMO TYPE: \"javelins\"\n    AMMO COUNT: 5\n    NOTES: Can be thrown.\n  - NAME: \\weaponname{Breath Weapon}\n    ATTACK: '{\\small\\statdc{CON}} \\textsc{dex}'\n    DAMAGE: 2d6\n    TYPE: lightning\n    RANGE: 30¬†ft\n    NOTES: Creatures in a 30-foot line take full damage on a failed save or half on a success.\n\nFEATURES:\n  - name: Military Rank\n    description: Advantage on checks in social situations that involve NPCs with military experience.\n  - name: Resistance (Lightning)\n    description: You take half damage from lightning.\n  - name: Breath Weapon\n    description: >-\n      All targets in a line 30¬†ft long take 2d6 lightning damage,\n      or half damage on a \\statdc{CON} \\textsc{dex} save.\n  - name: Divine Sense\n    description: As an action, you know the location of any consecrated or desecrated object or place or any celestial, fiend, or undead within 60 ft. (4 uses per long rest).\n  - name: Lay on Hands\n    description: >-\n      You have 5 HP in a healing pool.\n      As an action, heal a touched creature 1¬†HP (as many points as\n      you like up to¬†5) or spend 5¬†points to cure a disease or poison\n      affecting one creature.\n  - name: Chain Mail\n    description: You have disadvantage on Stealth checks while wearing chain-mail armor.\n\n\"SUGGESTED MOTIVATIONS\":\n  - Earn glory.\n  - Do good.\n  - Mete out justice.\n\n\"SUGGESTED NAMES\":\n  - Raihan or Raina\n\nPREGENERATED: true\nSHEET ORIGIN: Paladin by NoxAeternus (best at 3 columns)\nLAYOUT: 3col\n"
    },
    {
        origin: "Rogue by NoxAeternus (best at 3 columns)",
        content: "\"CHARACTER NAME\": \"\"\n\"CLASS & LEVEL\": Rogue 1\n\"BACKGROUND\": Alchemist‚Äôs Apprentice\n\"PLAYER NAME\": \"\"\n\"RACE\": Halfling\n\"ALIGNMENT\": \"\"\n\"EXPERIENCE POINTS\": \"\"\n\n# ability scores ‚Äî only the score in the lower oval\nSTR: 10\nDEX: 17\nCON: 12\nINT: 14\nWIS: 8\nCHA: 14\n\n\"PROFICIENCY BONUS\": +2\n\"PASSIVE PERCEPTION\": 9\n\"MAX HP\": 15\n\"CURRENT HIT POINTS\": \"\"\n\"INITIATIVE\": \"+3\"\n\"SPEED\": 25\n\"ARMOR CLASS\": 14\n\"SENSES\": \"\"\n\"HIT DICE\": d8\n\n# coin totals\nCP: \"\"\nSP: \"\"\nEP: \"\"\nGP: 10\nPP: \"\"\n\nMAIN PROFICIENCIES:\n  - Skills:\n    - Acrobatics\n    - Animal Handling\n    - Deception\n    - Stealth (EXPERT)\n    - Investigation (EXPERT)\n\n  - Tools:\n    - Alchemist‚Äôs Tools\n    - Vehicles (Land)\n    - Thieves‚Äô Tools\n\n  - Notes:\n    - Advantage on saves against fright.\n    - EXPERT means to double your proficiency bonus for that skill¬†(+4)\n\nOTHER PROFICIENCIES:\n  - Languages: Common, Halfling, Thieves Cant\n  - Armor: Light\n  - Weapons: Simple & Hand Crossbow, Longsword, Rapier, Shortsword\n\nEQUIPMENT:\n  - Leather Armor\n  - Alchemist‚Äôs Tools\n  - Thieves‚Äô Tools\n  - Iron Pot\n  - Shovel\n  - Backpack\n  - Crowbar\n  - Hammer\n  - Bag of 1 000 Ball Bearings\n  - Hooded Lantern\n  - Flask of Oil (2)\n  - Rations (10)\n  - Waterskin\n  - 50 ft. Rope\n  - Grappling Hook\n\nATTACKS:\n  - NAME: Rapier\n    ATTACK: \"+5\"\n    DAMAGE: 1d8+3\n    TYPE: piercing\n    RANGE: 5 ft.\n    NOTES: Uses \\textsc{dex} modifier, not \\textsc{str}.\n  - NAME: Shortbow\n    ATTACK: \"+5\"\n    DAMAGE: 1d6+3\n    TYPE: piercing\n    RANGE: 80/320 ft.\n    AMMO TYPE: \"arrows\"\n    AMMO COUNT: 20\n  - NAME: Dagger\n    ATTACK: \"+5\"\n    DAMAGE: 1d4+3\n    TYPE: piercing\n    RANGE: 20/60 ft.\n    NOTES: Uses \\textsc{dex}, not \\textsc{str}.  Can be thrown.\n    AMMO COUNT: 2\n    AMMO TYPE: daggers\n\nFEATURES:\n  - name: Rustic Hospitality\n    description: As long as you are no threat to them, most commoners will give you and your party a place to sleep free of charge.\n  - name: Lucky\n    description: Once per long rest, when you roll a 1 on a d20 you may reroll it once.\n  - name: Halfling Nimbleness\n    description: You can move through squares occupied by creatures larger than yourself (medium or bigger).\n  - name: Brave\n    description: You have advantage on saving throws against being frightened.\n  - name: Sneak Attack\n    description: Once per turn you may add +1d6 damage to an attack against a target that is unaware of you or whose attention is elsewhere.\n  - name: Expertise\n    description: Double your proficiency bonus on Stealth and Investigation checks (noted on the skill list).\n\n\"SUGGESTED MOTIVATIONS\":\n  - Amass wealth.\n  - Earn recognition.\n  - Stave off boredom.\n\n\"SUGGESTED NAMES\":\n  - Pippin or Piper\n\nPREGENERATED: true\nSHEET ORIGIN: Rogue by NoxAeternus (best at 3 columns)\nLAYOUT: 3col\n"
    },
    {
        origin: "Monk by NoxAeternus (best at 3 columns)",
        content: "\"CHARACTER NAME\": \"\"\n\"CLASS & LEVEL\": Monk 1\n\"BACKGROUND\": Professional Boxer\n\"PLAYER NAME\": \"\"\n\"RACE\": Half-Elf\n\"ALIGNMENT\": \"\"\n\"EXPERIENCE POINTS\": \"\"\n\n# ability scores ‚Äî only the score in the lower oval\nSTR: 10\nDEX: 16\nCON: 12\nINT: 14\nWIS: 14\nCHA: 10\n\n\"PROFICIENCY BONUS\": +2\n\"PASSIVE PERCEPTION\": 12\n\"MAX HP\": 15\n\"CURRENT HIT POINTS\": \"\"\n\"INITIATIVE\": \"+3\"\n\"SPEED\": 30 ft\n\"ARMOR CLASS\": 15\n\"SENSES\": Darkvision 60 ft.\n\"HIT DICE\": d8\n\n# coin totals\nCP: \"\"\nSP: \"\"\nEP: \"\"\nGP: \"\"\nPP: \"\"\n\nMAIN PROFICIENCIES:\n  - Skills:\n    - Acrobatics\n    - History\n    - Insight\n    - Investigation\n    - Performance\n    - Stealth\n\n  - Tools:\n    - Leatherworker‚Äôs Tools\n    - Thieves‚Äô Tools\nOTHER PROFICIENCIES:\n  - Languages: Common, Elf, Dwarf, Orc\n  - Armor: None\n  - Weapons: Simple Weapons, Shortsword\n\nEQUIPMENT:\n  - Backpack\n  - Bedroll\n  - Mess Kit\n  - Tinderbox\n  - Torches (10)\n  - Rations (10)\n  - Waterskin\n  - 50 ft. Rope\n  - Thieves‚Äô Tools\n  - Leatherworker‚Äôs Tools\n\nATTACKS:\n  - NAME: Punch\n    ATTACK: \"+5\"\n    DAMAGE: 1d4+3\n    TYPE: bludgeoning\n    RANGE: 5 ft.\n    NOTES: Unarmed strike.\n  - NAME: Brass Knuckle\n    ATTACK: \"+5\"\n    DAMAGE: 1d6+3\n    TYPE: bludgeoning\n    RANGE: 5 ft.\n  - NAME: Dart\n    ATTACK: \"+5\"\n    DAMAGE: 1d4+3\n    TYPE: piercing\n    RANGE: 20/60 ft.\n    AMMO TYPE: \"darts\"\n    AMMO COUNT: 10\n\nFEATURES:\n  - name: Boxer of Legend\n    description: You have advantage on Charisma checks against anyone who recognizes your boxing moniker ‚ÄúHammerfist.‚Äù\n  - name: Darkvision 60 ft.\n    description: You can see in dim light as if it were bright and in darkness as if it were dim (disadvantage on Perception in darkness).\n  - name: Unarmored Defense\n    description: While wearing no armor, your AC equals 10 + Dex + Wis.\n  - name: Martial Arts\n    description: Use fists, shortsword, or any simple weapon (not heavy or two-handed). Must not wear armor or use a shield. ‚Ä¢ Use \\textsc{dex} for attack and damage ‚Ä¢ Unarmed damage is¬†d4 ‚Ä¢ After taking the Attack action, you may make one punch as a bonus action.\n  - name: Fey Ancestry\n    description: Advantage on saving throws against being charmed, and magic can‚Äôt put you to sleep.\n\n\"SUGGESTED MOTIVATIONS\":\n  - Perfect Self\n  - Discover Truth\n  - Stave Off Boredom\n\n\"SUGGESTED NAMES\":\n  - Syrun or Syralla\n\nPREGENERATED: true\nSHEET ORIGIN: Monk by NoxAeternus (best at 3 columns)\nLAYOUT: 3col\n"
    },
    {
        origin: "Wizard by NoxAeternus (best at 3 columns)",
        content: "\"CHARACTER NAME\": \"\"\n\"CLASS & LEVEL\": Wizard 1\n\"BACKGROUND\": Sage\n\"PLAYER NAME\": \"\"\n\"RACE\": High Elf\n\"ALIGNMENT\": \"\"\n\"EXPERIENCE POINTS\": \"\"\n\n# ability scores ‚Äî only the score in the lower oval\nSTR: 8\nDEX: 14\nCON: 12\nINT: 16\nWIS: 14\nCHA: 10\n\n\"PROFICIENCY BONUS\": +2\n\"PASSIVE PERCEPTION\": 14\n\"MAX HP\": 12\n\"CURRENT HIT POINTS\": \"\"\n\"INITIATIVE\": \"+2\"\n\"SPEED\": 30 ft\n\"ARMOR CLASS\": 12\n\"SENSES\": Darkvision 60 ft.\n\"HIT DICE\": d6\n\n# coin totals\nCP: \"\"\nSP: \"\"\nEP: \"\"\nGP: 10\nPP: \"\"\n\nPROFICIENCIES:\n  - Skills:\n    - Arcana\n    - History\n    - Insight\n    - Nature\n    - Perception\n\n  - Notes:\n      - Advantage on saves against charm.\n      - Magic can't put you to sleep.\nOTHER PROFICIENCIES:\n  - Languages: Common, Elvish, Draconic, Dwarvish, Orcish\n  - Armor: None\n  - Weapons: Dagger, Dart, Sling, Quarterstaff, Light Crossbow, Longsword, Shortsword, Longbow, Shortbow\n\nEQUIPMENT:\n  - Common Clothes\n  - Bottle of Black Ink\n  - Quill\n  - Small Knife\n  - Parchment (10)\n  - Spellbook\n  - Component Pouch\n  - Rations (10)\n  - Waterskin\n\nATTACKS:\n  - NAME: Longbow\n    ATTACK: \"+4\"\n    DAMAGE: 1d8+2\n    TYPE: piercing\n    RANGE: 150/600 ft.\n    AMMO TYPE: \"arrows\"\n    AMMO COUNT: 20\n  - NAME: Ray of Frost\n    ATTACK: \"+5\"\n    DAMAGE: 1d8\n    TYPE: cold\n    RANGE: 60 ft.\n  - NAME: Magic Missile\n    ATTACK: Hits\n    DAMAGE: 1d4+1\n    TYPE: force\n    RANGE: 120 ft.\n    NOTES: >-\n      When cast creates 3¬†darts that can target multiple\n      creatures within 120¬†ft. Damage is for 1¬†dart.\n      Casting uses a 1st-level spell slot.\n\nFEATURES FONT: \\small\nMAGIC FONT: \\footnotesize\nMAGIC:\n  - level: 0                                  # CANTRIPS\n  - name: Dancing Lights\n    description: Create up to 4 glowing lights that move independently within 120 ft; last 1 min while you concentrate.\n#  - name: Fire Bolt\n#    description: Ranged spell attack +5, 120 ft; 1d10 fire damage.\n#  - name: Light\n#    description: Touch an object to shed bright light for 20 ft and dim for 20 ft for 1 hr.\n  - name: Ray of Frost\n    description: Ranged spell attack +5, 60 ft; 1d8 cold and target‚Äôs speed ‚àí10 ft until your next turn.\n  - name: Mage Hand\n    description: Spectral hand (30 ft) can manipulate objects up to 10 lbs for 1 min.\n#  - name: Shocking Grasp\n#    description: Melee spell attack +5; 1d8 lightning, advantage on metal armor; target can‚Äôt take reactions until its next turn.\n  - level: {number: 1, slots: 2}                                  # 1st LEVEL\n  - name: Detect Magic [R]\n    description: Sense magic within 30 ft for 10 min; ritual.\n  - name: Feather Fall\n    description: Reaction; up to 5 creatures falling within 60 ft fall slowly, take no damage.\n  - name: Mage Armor\n    description: Touch unarmored creature; AC = 13 + Dex mod for 8 hr.\n  - name: Magic Missile\n    description: Create 3 darts (120 ft) that each deal 1d4+1 force; darts may target different creatures; uses 1st-level slot.\n  - name: Shield\n    description: >-\n      Reaction; +5 AC until start of next turn, including triggering attack.\n      No¬†damage from \\emph{magic missile}.\n  - name: Silent Image\n    description: Create a visual illusion in a 15-ft cube (120 ft) for 10 min (concentration); Investigation DC 13 reveals.\n  - name: Sleep\n    description: Roll 5d8; up to that total HP of creatures within 90 ft fall asleep for 1 min (ending on shake/damage).\n    offensive: true\n\nFEATURES:\n  - name: Researcher\n    description: You know where to find written or scholarly information; a check may be required for obscure topics.\n  - name: Darkvision 60 ft\n    description: See in dim light as if bright and in darkness as if dim (disadvantage on Perception in darkness).\n  - name: Trance\n    description: Elves don‚Äôt sleep; meditate 4 hr to gain a long-rest benefit.\n  - name: Arcane Recovery\n    description: >-\n      After a short rest, regain one expended 1st-level\n      spell slot (1/day).\n  - name: Scribe Spell\n    description: Copying a spell into your spellbook costs 2 hours & 50 gp per spell level.\n  - name: Fey Ancestry\n    description: Advantage on saves versus charm; magic can‚Äôt put you to sleep.\n\n\"SUGGESTED MOTIVATIONS\":\n  - Accrue power\n  - Gain knowledge\n  - Discover truth\n\n\"SUGGESTED NAMES\":\n  - Eldarion or Eldariel\n\nPREGENERATED: true\nDOCUMENT FONT: 10pt\nSHEET ORIGIN: Wizard by NoxAeternus (best at 3 columns)\nLAYOUT: 3col\n"
    },
    {
        origin: "Sorcerer by NoxAeternus (best at 3 columns)",
        content: "\"CHARACTER NAME\": \"\"\n\"CLASS & LEVEL\": Sorcerer 1\n\"BACKGROUND\": Town Watch\n\"PLAYER NAME\": \"\"\n\"RACE\": Human\n\"ALIGNMENT\": \"\"\n\"EXPERIENCE POINTS\": \"\"\n\n# ability scores ‚Äî only the score in the lower oval\nSTR: 9\nDEX: 14\nCON: 15\nINT: 13\nWIS: 11\nCHA: 16\n\n\"PROFICIENCY BONUS\": +2\n\"PASSIVE PERCEPTION\": 12\n\"MAX HP\": 14\n\"CURRENT HIT POINTS\": \"\"\n\"INITIATIVE\": \"+2\"\n\"SPEED\": 30 ft\n\"ARMOR CLASS\": 15\n\"SENSES\": \"\"\n\"HIT DICE\": d6\n\n# coin totals\nCP: \"\"\nSP: \"\"\nEP: \"\"\nGP: 10\nPP: \"\"\n\nPROFICIENCIES:\n  - Skills:\n    - Arcana\n    - Insight\n    - Nature\n    - Perception\nOTHER PROFICIENCIES:\n  - \"Languages: Common, Elf, Draconic\"\n  - \"Armor: None\"\n  - Weapons: Daggers, Darts, Slings, Quarterstaff, Light Crossbow\n\nEQUIPMENT:\n  - \"Arcane Focus: Staff\"\n  - Backpack\n  - Bedroll\n  - Mess Kit\n  - Tinderbox\n  - 'Torches (10)'\n  - 'Rations (10)'\n  - Waterskin\n  - 50 ft Rope\n\nATTACKS:\n  - NAME: Light crossbow\n    ATTACK: \"+4\"\n    DAMAGE: 1d8+2\n    TYPE: piercing\n    RANGE: 80/320¬†ft\n    AMMO TYPE: \"bolts\"\n    AMMO COUNT: 20\n  - NAME: Burning Hands\n    ATTACK: \\textsc{dex}, {\\small\\spelldc}\n    DAMAGE: 3d6\n    TYPE: fire\n#    RANGE: 15¬†ft\n    NOTES: >-\n      Hits all creatures in a 15¬†ft cone.\n      Half damage on a \\spelldc\\ \\textsc{dex} save.\n      A hit target is 10¬†ft slower for 1¬†turn.\n# until      your next turn starts.\n  - NAME: Shocking Grasp\n    ATTACK: \"+5\"\n    DAMAGE: 1d8\n    TYPE: lightning\n    RANGE: touching distance\n    NOTES: >-\n      Advantage vs creatures wearing metal armor.\n      A hit target can't take reactions until its next turn.\n  - NAME: Magic Missile\n    ATTACK: Hits\n    DAMAGE: 1d4+1\n    TYPE: force\n#    RANGE: 120 ft.\n    NOTES: >-\n      Creates 3¬†darts targeting up to 3 creatures within\n      120¬†ft. 1d4\\psam\\ per dart.\n      Casting uses a 1st-level spell slot.\n\nMAGIC FONT: \\normalsize\nMAGIC:\n  - level: 0                               # CANTRIPS\n  - name: Fire Bolt\n    description: Ranged spell attack +5, 120 ft; 1d10 fire damage.\n  - name: Ray of Frost\n    description: Ranged spell attack +5, 60 ft; 1d8 cold damage and target‚Äôs speed ‚àí10 ft. until your next turn.\n  - name: Shocking Grasp\n    description: Melee spell attack +5, 1d8 lightning; advantage on creatures wearing metal armor; target can‚Äôt take reactions until its next turn.\n  - name: Light\n    description: Touched object shines like a torch for 1 hour.\n  - level: {number: 1, slots: 2}                               # 1st LEVEL\n  - name: Burning Hands\n    description: >-\n      Emit 15-ft cone of fire; each affected creature takes 3d6\n      fire damage (half damage on successful \\spelldc\\ \\textsc{dex} save).\n  - name: Magic Missile\n    description: Create three darts that each deal 1d4+1 force damage to a target you choose; darts never miss.\n\nFEATURES:\n  - name: Stand Watch\n    description: While you are on watch your passive perception is 18.\n  - name: Sorcerous Origin ‚Äì Draconic (Silver, Cold)\n    description: Add double proficiency bonus on Charisma checks vs. dragons. Gain +1 HP per sorcerer level. Unarmored AC = 13 + Dex mod.\n  - name: Unarmored Defense\n    description: >-\n      Your AC while not wearing armor equals 13 + your Dexterity modifier\n      (Draconic Resilience).\n\n\"SUGGESTED MOTIVATIONS\":\n  - Accrue Power\n  - Achieve Status\n  - Vanquish Evil\n\n\"SUGGESTED NAMES\":\n  - Dominick or Dominara\n\nPREGENERATED: true\n\nDOCUMENT FONT: 10pt\nSHEET ORIGIN: Sorcerer by NoxAeternus (best at 3 columns)\nLAYOUT: 3col\n"
    }
];


        // Sample YAML loading functions
        function populateSampleDropdown() {
            const dropdown = document.getElementById('sample-yaml-dropdown');
            const button = document.getElementById('load-sample-button');
            if (!dropdown || typeof EMBEDDED_YAMLS === 'undefined') return;

            // Clear existing options except the first one
            while (dropdown.children.length > 1) {
                dropdown.removeChild(dropdown.lastChild);
            }

            // Add options for each embedded YAML
            EMBEDDED_YAMLS.forEach((yamlData, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = yamlData.origin;
                dropdown.appendChild(option);
            });

            // Add event listener to enable/disable button based on selection
            dropdown.addEventListener('change', function() {
                if (button) {
                    button.disabled = (this.value === '');
                    console.log('Dropdown changed. Value:', this.value, 'Button disabled:', button.disabled);
                }
            });

            // Ensure button starts disabled
            if (button) {
                button.disabled = true;
            }
        }

        function loadSampleYAML() {
            const dropdown = document.getElementById('sample-yaml-dropdown');
            const selectedIndex = dropdown.value;

            if (selectedIndex === '' || typeof EMBEDDED_YAMLS === 'undefined') {
                updateStatusBar('Please select a character from the dropdown.', true);
                return;
            }

            const yamlData = EMBEDDED_YAMLS[selectedIndex];
            if (!yamlData) {
                updateStatusBar('Error: Selected character data not found.', true);
                return;
            }

            try {
                // Use the existing parseYAMLIntoForm function
                parseYAMLIntoForm(yamlData.content);
                loadedFileName = yamlData.origin + '.yaml';
                isDirty = false;
                updateStatusBar('Loaded sample character: ' + yamlData.origin);
                updateDownloadButtonText();
                setupChangeTracking();
            } catch (error) {
                updateStatusBar('Error loading sample character: ' + error.message, true);
            }
        }

        // Initialize with some default entries
        document.addEventListener('DOMContentLoaded', function() {
            addAttack();
            addFeature();
            setupChangeTracking();

            // Populate sample YAML dropdown
            populateSampleDropdown();

            // Initialize and update download button text
            updateDownloadButtonText();
            const characterNameField = document.getElementById('character-name');
            const classField = document.getElementById('class');
            characterNameField.addEventListener('input', updateDownloadButtonText);
            characterNameField.addEventListener('change', updateDownloadButtonText);
            classField.addEventListener('input', updateDownloadButtonText);
            classField.addEventListener('change', updateDownloadButtonText);
        });

        // Global keyboard shortcut handler
        document.addEventListener('keydown', function(event) {
            // Check for Ctrl+Enter (or Cmd+Enter on Mac)
            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                event.preventDefault();
                
                // Find which section the focus is in
                const activeElement = document.activeElement;
                const attacksSection = document.getElementById('attacks-list');
                const magicSection = document.getElementById('magic-list');
                const featuresSection = document.getElementById('features-list');
                
                // Check if focus is within any of these sections
                if (attacksSection && attacksSection.contains(activeElement)) {
                    addAttack();
                    // Focus on the name field of the new attack
                    setTimeout(() => {
                        const newAttack = document.querySelector('.attack-item:last-child [data-field="name"]');
                        if (newAttack) newAttack.focus();
                    }, 10);
                } else if (magicSection && magicSection.contains(activeElement)) {
                    // Find which spell level section we're in
                    const spellLevelDiv = activeElement.closest('.spell-level');
                    const level = spellLevelDiv ? spellLevelDiv.getAttribute('data-level') : '0';
                    addSpellToLevel(parseInt(level));
                    // Focus on the name field of the new spell
                    setTimeout(() => {
                        const container = spellLevelDiv.querySelector('.spells-container');
                        const newSpell = container ? container.querySelector('.spell-item:last-child [data-field="name"]') : null;
                        if (newSpell) newSpell.focus();
                    }, 10);
                } else if (featuresSection && featuresSection.contains(activeElement)) {
                    addFeature();
                    // Focus on the name field of the new feature
                    setTimeout(() => {
                        const newFeature = document.querySelector('.feature-item:last-child [data-field="name"]');
                        if (newFeature) newFeature.focus();
                    }, 10);
                } else {
                    // If not in a specific section, check which section is closest or most recently used
                    // Default to adding an attack
                    addAttack();
                    setTimeout(() => {
                        const newAttack = document.querySelector('.attack-item:last-child [data-field="name"]');
                        if (newAttack) newAttack.focus();
                    }, 10);
                }
            }
        });

        function toggleMagic() {
            const magicContent = document.getElementById('magic-content');
            const magicHeader = document.getElementById('magic-header');
            
            if (magicContent.style.display === 'none') {
                magicContent.style.display = 'block';
                magicHeader.textContent = 'Magic';
                // Always open cantrips automatically when magic section opens
                if (!document.querySelector('[data-level="0"]')) {
                    openSpellLevel(0);
                }
            } else {
                magicContent.style.display = 'none';
                magicHeader.textContent = 'Magic (click to open)';
            }
        }
        
        function getSpellLevelName(level) {
            if (level === 0) return 'Cantrips';
            const suffixes = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th'];
            return `${level}${suffixes[level]}-Level Spells`;
        }
        
        function openSpellLevel(level) {
            const magicLevels = document.getElementById('magic-levels');
            const levelDiv = document.createElement('div');
            levelDiv.className = 'spell-level';
            levelDiv.setAttribute('data-level', level);
            
            const levelName = level === 0 ? 'Cantrips' : `${getSpellLevelName(level)} (<input type="number" min="0" max="9" maxlength="1" data-slots="${level}" placeholder="0" style="width: 2.5em; border: 1px solid #999; text-align: center;"> slots)`;
            
            levelDiv.innerHTML = `
                <h3>${levelName}</h3>
                <div class="spells-container"></div>
                <button type="button" class="add-button" onclick="addSpellToLevel(${level})">Add ${level === 0 ? 'Cantrip' : getSpellLevelName(level).replace('-Level Spells', '-Level Spell')}</button>
            `;
            
            magicLevels.appendChild(levelDiv);
            
            // Add change tracking for the new slot input if it exists
            const slotsInputEl = levelDiv.querySelector('[data-slots]');
            if (slotsInputEl) {
                slotsInputEl.addEventListener('input', markDirty);
                slotsInputEl.addEventListener('change', markDirty);
            }
            
            updateNextLevelButton();
        }
        
        function showNextLevelButton(level) {
            const container = document.getElementById('next-level-button-container');
            const nextLevel = level;
            const maxLevel = 9;
            
            if (nextLevel <= maxLevel) {
                const levelName = nextLevel === 0 ? 'Cantrips' : getSpellLevelName(nextLevel);
                container.innerHTML = `
                    <button type="button" class="add-button" onclick="openSpellLevel(${nextLevel}); addSpellToLevel(${nextLevel});">Open ${levelName}</button>
                `;
            } else {
                container.innerHTML = '';
            }
        }
        
        function updateNextLevelButton() {
            const existingLevels = Array.from(document.querySelectorAll('.spell-level')).map(el => parseInt(el.getAttribute('data-level')));
            if (existingLevels.length === 0) {
                showNextLevelButton(0);
                return;
            }
            
            const maxExistingLevel = Math.max(...existingLevels);
            const nextLevel = maxExistingLevel + 1;
            showNextLevelButton(nextLevel);
        }

        function addAttack() {
            const container = document.getElementById('attacks-list');
            const item = document.createElement('div');
            item.style.textAlign = 'left'; // Force left alignment
            item.className = 'attack-item';
            item.innerHTML = `
                <div class="attack-fields">
                    <input type="text" placeholder="Weapon" data-field="name" />
                    <input type="text" placeholder="Attack Bonus" data-field="attack" />
                    <input type="text" placeholder="Damage Amount" data-field="damage" />
                    <input type="text" placeholder="Damage Type" data-field="type" list="damage-types" />
                    <datalist id="damage-types">
                        <option value="slashing">
                        <option value="piercing">
                        <option value="bludgeoning">
                        <option value="acid">
                        <option value="cold">
                        <option value="fire">
                        <option value="force">
                        <option value="lightning">
                        <option value="necrotic">
                        <option value="poison">
                        <option value="psychic">
                        <option value="radiant">
                        <option value="thunder">
                    </datalist>
                    <input type="text" placeholder="Range" data-field="range" class="range-field" />
                    <input type="text" placeholder="Ammo" data-field="ammo" class="ammo-field" />
                </div>
                <button type="button" onclick="this.parentElement.remove()">Remove Attack</button>
            `;
            container.appendChild(item);
            
            // Add change tracking to new elements
            item.querySelectorAll('input, textarea, select').forEach(el => {
                el.addEventListener('input', markDirty);
                el.addEventListener('change', markDirty);
            });
        }

        function addSpellToLevel(level) {
            // Ensure the level exists first
            let spellLevelDiv = document.querySelector(`[data-level="${level}"]`);
            if (!spellLevelDiv) {
                openSpellLevel(level);
                spellLevelDiv = document.querySelector(`[data-level="${level}"]`);
            }
            
            const spellContainer = spellLevelDiv.querySelector('.spells-container');
            const item = document.createElement('div');
            item.className = 'spell-item';
            item.innerHTML = `
                <div class="field-group">
                    <label>Name</label>
                    <input type="text" placeholder="e.g., Magic Missile" data-field="name" data-level="${level}" />
                </div>
                <div class="field-group">
                    <label>Description</label>
                    <textarea placeholder="Spell description..." data-field="description" rows="2"></textarea>
                </div>
                <button type="button" onclick="this.parentElement.remove(); setupChangeTracking();">Remove Spell</button>
            `;
            spellContainer.appendChild(item);
            
            // Add change tracking to new elements
            item.querySelectorAll('input, textarea, select').forEach(el => {
                el.addEventListener('input', markDirty);
                el.addEventListener('change', markDirty);
            });
        }
        
        // Legacy function for compatibility
        function addSpell() {
            // Bug fix: addSpell should never be called with arguments; use addSpellToLevel instead
            if (arguments.length > 0) {
                console.error('BUG: addSpell() called with arguments. Use addSpellToLevel() instead.');
                throw new Error('addSpell() should not be called with arguments');
            }
            addSpellToLevel(0); // Default to cantrips
        }

        function addFeature() {
            const container = document.getElementById('features-list');
            const item = document.createElement('div');
            item.className = 'feature-item';
            item.style.textAlign = 'left'; // Force left alignment
            item.innerHTML = `
                <div style="display: flex; align-items: center; gap: 0.5em; margin-bottom: 0.5em;">
                    <label style="white-space: nowrap;">Name</label>
                    <input type="text" placeholder="e.g., Rage, Darkvision" data-field="name" style="flex: 1;" />
                </div>
                <div style="margin-bottom: 0.5em;">
                    <label style="display: block; margin-bottom: 0.2em;">Description</label>
                    <textarea placeholder="Feature description..." data-field="description" rows="2" style="width: 100%; box-sizing: border-box;"></textarea>
                </div>
                <button type="button" onclick="this.parentElement.remove()">Remove Feature</button>
            `;
            container.appendChild(item);
            
            // Add change tracking to new elements
            item.querySelectorAll('input, textarea, select').forEach(el => {
                el.addEventListener('input', markDirty);
                el.addEventListener('change', markDirty);
            });
        }

        let isDirty = false;
        let loadedFileName = '';
        let originalYamlData = null;  // Stores complete parsed YAML for passthrough of unknown fields

        function loadYAMLFile(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        parseYAMLIntoForm(e.target.result);
                        loadedFileName = file.name;
                        isDirty = false;
                        updateStatusBar();
                        setupChangeTracking();
                        updateDownloadButtonText();
                    } catch (error) {
                        updateStatusBar('Error loading YAML file: ' + error.message, true);
                    }
                };
                reader.readAsText(file);
            }
        }

        function updateStatusBar(message = null, isError = false) {
            const statusBar = document.getElementById('status-bar');
            if (message) {
                statusBar.innerHTML = `<span style="color: ${isError ? '#d32f2f' : '#666'}">${message}</span>`;
            } else if (loadedFileName) {
                const dirtyMark = isDirty ? ' (dirty)' : '';
                statusBar.innerHTML = `Loaded from <strong>${loadedFileName}</strong>${dirtyMark}`;
            } else {
                statusBar.innerHTML = '<strong>Tip:</strong> Use <kbd>Ctrl+Enter</kbd> (or <kbd>Cmd+Enter</kbd> on Mac) to quickly add items when focused in Attacks, Spells, or Features sections';
            }
        }

        function markDirty() {
            if (!isDirty) {
                isDirty = true;
                updateStatusBar();
            }
        }

        function setupChangeTracking() {
            // Remove existing listeners first
            document.querySelectorAll('#character-form input, #character-form textarea, #character-form select').forEach(el => {
                el.removeEventListener('input', markDirty);
                el.removeEventListener('change', markDirty);
            });
            
            // Add listeners to all form elements
            document.querySelectorAll('#character-form input, #character-form textarea, #character-form select').forEach(el => {
                el.addEventListener('input', markDirty);
                el.addEventListener('change', markDirty);
                // Update button text when character name or class changes
                if (el.id === 'character-name' || el.id === 'class') {
                    el.addEventListener('input', updateDownloadButtonText);
                }
            });
        }

        // Field factory functions
        function textField(yamlKey, selector) {
            return {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    const value = data[yamlKey];
                    if (el && value !== undefined && value !== null) {
                        el.value = value.toString();
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    data[yamlKey] = el?.value || '';
                }
            };
        }

        function numberField(yamlKey, selector) {
            return {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    const value = data[yamlKey];
                    if (el && value !== undefined && value !== null) {
                        el.value = value.toString();
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    const value = el?.value || '';
                    data[yamlKey] = value ? (parseInt(value) || value) : value;
                }
            };
        }

        function checkboxField(yamlKey, selector, defaultState = false) {
            return {
                populate(data) {
                    const el = document.querySelector(selector);
                    if (el) {
                        const value = data[yamlKey];
                        console.log(`${yamlKey} value:`, value, 'type:', typeof value);
                        // Use default state if yamlKey is not present in data
                        const shouldCheck = value !== undefined ? !ifDNDfalse(value) : defaultState;
                        console.log('Should check:', shouldCheck);
                        el.checked = shouldCheck;
                    }
                },
                capture(data) {
                    const el = document.querySelector(selector);
                    data[yamlKey] = el?.checked || false;
                }
            };
        }

        function radioField(yamlKey, name) {
            return {
                populate(data) {
                    const value = data[yamlKey];
                    if (value !== undefined && value !== null) {
                        const radio = document.querySelector(`input[name="${name}"][value="${value}"]`);
                        if (radio) {
                            radio.checked = true;
                        }
                    }
                },
                capture(data) {
                    const checkedRadio = document.querySelector(`input[name="${name}"]:checked`);
                    if (checkedRadio) {
                        data[yamlKey] = checkedRadio.value;
                    }
                }
            };
        }

        // Complex field factories
        function arrayField(yamlKey, selector, itemProcessor = null) {
            return {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    if (el && data[yamlKey] && Array.isArray(data[yamlKey])) {
                        const items = itemProcessor 
                            ? data[yamlKey].map(itemProcessor)
                            : data[yamlKey].map(item => item?.toString() || '');
                        el.value = items.join('\n');
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector(selector);
                    const text = el?.value || '';
                    if (text.trim()) {
                        const lines = text.split('\n').filter(line => line.trim());
                        data[yamlKey] = itemProcessor ? lines.map(itemProcessor) : lines;
                    } else {
                        data[yamlKey] = [];
                    }
                }
            };
        }

        function classLevelField() {
            return {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const setFormValue = (selector, value) => {
                        const el = form.querySelector(selector);
                        if (el && value !== undefined && value !== null) {
                            el.value = value.toString();
                        }
                    };
                    
                    // Handle "CLASS & LEVEL" format
                    if (data['CLASS & LEVEL']) {
                        const classLevel = data['CLASS & LEVEL'].toString();

                        // Try patterns in order: specialty format first, then simple format
                        let match = classLevel.match(/^([A-Za-z]+)\s*\(([^)]+)\)\s+(\d+)$/);
                        if (match) {
                            // Format: "Cleric (Life Domain) 1"
                            setFormValue('#class', match[1]);
                            setFormValue('#specialty', match[2]);
                            setFormValue('#level', match[3]);
                        } else {
                            match = classLevel.match(/^([A-Za-z]+)\s+(\d+)$/);
                            if (match) {
                                // Format: "Fighter 1"
                                setFormValue('#class', match[1]);
                                setFormValue('#level', match[2]);
                            } else {
                                match = classLevel.match(/^([A-Za-z]+)/);
                                if (match) {
                                    // Format: just class name
                                    setFormValue('#class', match[1]);
                                }
                            }
                        }
                    }
                    
                    // Override with individual fields if present
                    if (data['CLASS']) setFormValue('#class', data['CLASS']);
                    if (data['LEVEL']) setFormValue('#level', data['LEVEL']);
                    if (data['SPECIALTY']) setFormValue('#specialty', data['SPECIALTY']);
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const characterClass = form.querySelector('#class')?.value || '';
                    const level = form.querySelector('#level')?.value || '';
                    const specialty = form.querySelector('#specialty')?.value || '';

                    data['CLASS'] = characterClass;
                    data['LEVEL'] = level ? (parseInt(level) || level) : level;
                    if (specialty) data['SPECIALTY'] = specialty;
                }
            };
        }

        // Name-description pair handler - reusable for Features and Magic
        function nameDescPairs(yamlKey, itemSelector, addFunction) {
            return {
                populate(data) {
                    if (data[yamlKey] && Array.isArray(data[yamlKey])) {
                        // Clear existing items first
                        document.querySelectorAll(itemSelector).forEach(item => item.remove());
                        
                        data[yamlKey].forEach(item => {
                            if (item && typeof item === 'object' && item.name) {
                                addFunction();
                                const items = document.querySelectorAll(itemSelector);
                                const lastItem = items[items.length - 1];
                                if (lastItem) {
                                    const nameEl = lastItem.querySelector('[data-field="name"]');
                                    const descEl = lastItem.querySelector('[data-field="description"]');
                                    if (nameEl) nameEl.value = item.name || '';
                                    if (descEl) descEl.value = item.description || '';
                                }
                            }
                        });
                    }
                },
                capture(data) {
                    const items = [];
                    document.querySelectorAll(itemSelector).forEach(itemDiv => {
                        const name = itemDiv.querySelector('[data-field="name"]')?.value || '';
                        const description = itemDiv.querySelector('[data-field="description"]')?.value || '';

                        if (name || description) {
                            const item = {};
                            if (name) item.name = name;
                            if (description) item.description = description;
                            items.push(item);
                        }
                    });
                    data[yamlKey] = items;
                }
            };
        }

        // Attacks field factory
        function attacksField() {
            return {
                populate(data) {
                    if (data['ATTACKS'] && Array.isArray(data['ATTACKS'])) {
                        // Clear existing attacks first
                        document.querySelectorAll('.attack-item').forEach(item => item.remove());
                        
                        data['ATTACKS'].forEach(attack => {
                            if (attack && typeof attack === 'object') {
                                addAttack();
                                const items = document.querySelectorAll('.attack-item');
                                const lastItem = items[items.length - 1];
                                if (lastItem) {
                                    const nameEl = lastItem.querySelector('[data-field="name"]');
                                    const attackEl = lastItem.querySelector('[data-field="attack"]');
                                    const damageEl = lastItem.querySelector('[data-field="damage"]');
                                    const typeEl = lastItem.querySelector('[data-field="type"]');
                                    const rangeEl = lastItem.querySelector('[data-field="range"]');
                                    const ammoEl = lastItem.querySelector('[data-field="ammo"]');
                                    
                                    if (nameEl) nameEl.value = attack['NAME'] || '';
                                    if (attackEl) attackEl.value = attack['ATTACK'] || '';
                                    if (damageEl) damageEl.value = attack['DAMAGE'] || '';
                                    if (typeEl) typeEl.value = attack['TYPE'] || '';
                                    if (rangeEl) rangeEl.value = attack['RANGE'] || '';
                                    if (ammoEl) ammoEl.value = attack['AMMO'] || '';
                                }
                            }
                        });
                    }
                },
                capture(data) {
                    const attacks = [];
                    document.querySelectorAll('.attack-item').forEach(attackDiv => {
                        const name = attackDiv.querySelector('[data-field="name"]')?.value || '';
                        const attack = attackDiv.querySelector('[data-field="attack"]')?.value || '';
                        const damage = attackDiv.querySelector('[data-field="damage"]')?.value || '';
                        const type = attackDiv.querySelector('[data-field="type"]')?.value || '';
                        const range = attackDiv.querySelector('[data-field="range"]')?.value || '';
                        const ammo = attackDiv.querySelector('[data-field="ammo"]')?.value || '';

                        if (name || attack || damage || type || range || ammo) {
                            attacks.push({
                                'NAME': name,
                                'ATTACK': attack,
                                'DAMAGE': damage,
                                'TYPE': type,
                                'RANGE': range,
                                'AMMO': ammo
                            });
                        }
                    });
                    data['ATTACKS'] = attacks;
                }
            };
        }

        // Magic field factory
        function magicField() {
            return {
                populate(data) {
                    if (data['MAGIC'] && Array.isArray(data['MAGIC'])) {
                        // Auto-open magic section
                        const magicContent = document.getElementById('magic-content');
                        const magicHeader = document.getElementById('magic-header');
                        if (magicContent && magicContent.style.display === 'none') {
                            magicContent.style.display = 'block';
                            magicHeader.textContent = 'Magic';
                        }
                        
                        // Clear existing spells first
                        document.querySelectorAll('.spell-item').forEach(item => item.remove());
                        
                        let currentLevel = null;
                        data['MAGIC'].forEach(item => {
                            if (item.level !== undefined) {
                                // This is a level header
                                if (typeof item.level === 'number') {
                                    currentLevel = item.level;
                                } else if (typeof item.level === 'object' && item.level.number !== undefined) {
                                    currentLevel = item.level.number;
                                    // Set slot count if provided
                                    const slotsInput = document.querySelector(`[data-slots="${currentLevel}"]`);
                                    if (slotsInput && item.level.slots !== undefined) {
                                        slotsInput.value = item.level.slots;
                                    }
                                }
                            } else if (item.name && currentLevel !== null) {
                                // This is a spell
                                addSpellToLevel(currentLevel);
                                const levelDiv = document.querySelector(`[data-level="${currentLevel}"]`);
                                const spellItems = levelDiv?.querySelectorAll('.spell-item');
                                const lastItem = spellItems?.[spellItems.length - 1];
                                if (lastItem) {
                                    const nameEl = lastItem.querySelector('[data-field="name"]');
                                    const descEl = lastItem.querySelector('[data-field="description"]');
                                    if (nameEl) nameEl.value = item.name || '';
                                    if (descEl) descEl.value = item.description || '';
                                }
                            }
                        });
                    }
                },
                capture(data) {
                    const magic = [];
                    const magicLevels = document.querySelectorAll('.spell-level');
                    let hasMagic = false;
                    
                    magicLevels.forEach(levelDiv => {
                        const level = levelDiv.getAttribute('data-level');
                        const spellItems = levelDiv.querySelectorAll('.spell-item');
                        const slotsInput = levelDiv.querySelector(`[data-slots="${level}"]`);
                        
                        if (spellItems.length > 0) {
                            // Add level header with slot information
                            if (level === '0') {
                                magic.push({ level: 0 });
                            } else {
                                const slots = slotsInput?.value || '';
                                if (slots) {
                                    magic.push({ level: { number: parseInt(level), slots: parseInt(slots) } });
                                } else {
                                    magic.push({ level: parseInt(level) });
                                }
                            }
                            
                            // Add spells for this level
                            spellItems.forEach(spellDiv => {
                                const name = spellDiv.querySelector('[data-field="name"]')?.value || '';
                                const description = spellDiv.querySelector('[data-field="description"]')?.value || '';
                                
                                if (name || description) {
                                    hasMagic = true;
                                    const spell = {};
                                    if (name) spell.name = name;
                                    if (description) spell.description = description;
                                    magic.push(spell);
                                }
                            });
                        }
                    });
                    
                    if (hasMagic) {
                        data['MAGIC'] = magic;
                    }
                }
            };
        }

        // Helper function to format proficiency items for display
        function stringOfProficienciesEntry(item) {
            if (typeof item === 'string') return item;
            if (typeof item === 'object' && item === null) return '';
            if (item && item.proficiencies_skip) return '';
            if (item && typeof item === 'object') {
                const keys = Object.keys(item);
                if (keys.length === 1) {
                    const key = keys[0];
                    const value = item[key];

                    // Handle array values as markdown lists
                    if (Array.isArray(value)) {
                        const listItems = value.map(v => `- ${v}`).join('\n');
                        return `${key}:\n${listItems}`;
                    }

                    // Handle special cases for backwards compatibility
                    if (key === 'Languages') return value;
                    if (key === 'Armor') return `${value} Armor`;
                    if (key === 'Weapons') return `${value} Weapons`;
                    return `${key}: ${value}`;
                }
            }
            return item?.toString() || '';
        }

        // Helper function to build combined proficiencies text for form display
        function buildProficienciesText(data) {
            let lines = [];

            function addToLines(dataField) {
                if (Array.isArray(dataField)) {
                    lines = lines.concat(dataField);
                }
            }

            addToLines(data['MAIN PROFICIENCIES']?.map(stringOfProficienciesEntry));
            addToLines(data['PROFICIENCIES']?.map(stringOfProficienciesEntry));

            // Add horizontal line if OTHER PROFICIENCIES exists and is non-empty
            if (data['OTHER PROFICIENCIES'] && Array.isArray(data['OTHER PROFICIENCIES']) && data['OTHER PROFICIENCIES'].length > 0) {
                addToLines(['----']);
                addToLines(data['OTHER PROFICIENCIES'].map(stringOfProficienciesEntry));
            }

            return lines.join('\n');
        }

        // Helper function to convert markdown lists back to objects
        function processMarkdownLists(lines) {
            const processed = [];
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];

                // Check if this line ends with a colon (possibly followed by spaces)
                if (line.match(/:\s*$/)) {
                    const key = line.replace(/:\s*$/, '');
                    const listItems = [];
                    i++; // Move to next line

                    // Collect markdown list items
                    while (i < lines.length) {
                        const nextLine = lines[i];
                        // Markdown list item: 0-3 spaces, then - or *, then at least one space
                        if (nextLine.match(/^ {0,3}[-*] /)) {
                            // Extract the item text after the markdown prefix
                            const item = nextLine.replace(/^ {0,3}[-*] /, '');
                            listItems.push(item);
                            i++;
                        } else {
                            // Not a list item, break out of list processing
                            break;
                        }
                    }

                    // Create object with key and array value if we found list items
                    if (listItems.length > 0) {
                        const obj = {};
                        obj[key] = listItems;
                        processed.push(obj);
                    } else {
                        // No list items found, treat as regular line
                        processed.push(line);
                        i++;
                    }
                } else {
                    // Regular line, keep as-is
                    processed.push(line);
                    i++;
                }
            }

            return processed;
        }

        // Helper function to parse proficiencies text and split by horizontal lines
        function parseProficienciesText(text) {
            const data = {};
            if (!text.trim()) {
                data['PROFICIENCIES'] = [];
                return data;
            }

            // Preserve blank lines - only trim whitespace from right side
            const allLines = text.split('\n').map(line => line.trimEnd());
            const horizontalLineIndex = allLines.findIndex(line => /^-{4,}[ \t]*$/.test(line.trim()));

            if (horizontalLineIndex >= 0) {
                // Split by horizontal line
                const mainLines = allLines.slice(0, horizontalLineIndex);
                const otherLines = allLines.slice(horizontalLineIndex + 1);

                if (mainLines.length > 0) data['MAIN PROFICIENCIES'] = processMarkdownLists(mainLines);
                if (otherLines.length > 0) data['OTHER PROFICIENCIES'] = processMarkdownLists(otherLines);
            } else {
                // No horizontal line, use legacy PROFICIENCIES field
                data['PROFICIENCIES'] = processMarkdownLists(allLines);
            }

            return data;
        }

        // Create the proficiencies field handler
        const proficiencies_fields = {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector('#proficiencies-text');
                    if (el) {
                        el.value = buildProficienciesText(data);
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const el = form.querySelector('#proficiencies-text');
                    const text = el?.value || '';
                    Object.assign(data, parseProficienciesText(text));
                }
            };

        // Font field factory - creates handlers for YAML font fields with radio button groups
        function fontField(yamlKey, buttonGroupName, skipValues = []) {
            return {
                populate(data) {
                    const fontValue = data[yamlKey];
                    let value = 'small'; // Default to small

                    if (fontValue && typeof fontValue === 'string') {
                        // Strip leading backslash if present
                        value = fontValue.replace(/^\\/, '');
                    }

                    // Set the radio button
                    const radio = document.querySelector(`input[name="${buttonGroupName}"][value="${value}"]`);
                    if (radio) {
                        radio.checked = true;
                    }
                },
                capture(data) {
                    const renderOption = document.querySelector(`input[name="${buttonGroupName}"]:checked`)?.value;
                    if (renderOption && !skipValues.includes(renderOption)) {
                        data[yamlKey] = '\\' + renderOption;
                    }
                }
            };
        }

        // Field registry
        const FIELDS = [
            // Character info fields
            textField('CHARACTER NAME', '#character-name'),
            textField('PLAYER NAME', '#player-name'),
            textField('RACE', '#race'),
            textField('BACKGROUND', '#background'),
            textField('ALIGNMENT', '#alignment'),
            textField('EXPERIENCE POINTS', '#experience'),
            textField('AGE', '#age'),
            textField('DESCRIPTION', '#description'),
            textField('MOTIVATION', '#motivation'),

            // Layout control
            radioField('LAYOUT', 'layout'),

            // Checkboxes
            checkboxField('COLOR', '#color', true),
            checkboxField('PREGENERATED', '#pregenerated', false),
            checkboxField('STONES', '#stones', false),
            
            // Class/Level complex logic
            classLevelField(),
            
            // Ability scores
            numberField('STR', '#str'),
            numberField('DEX', '#dex'),
            numberField('CON', '#con'),
            numberField('INT', '#int'),
            numberField('WIS', '#wis'),
            numberField('CHA', '#cha'),
            
            // Combat stats
            textField('PROFICIENCY BONUS', '#proficiency-bonus'),
            textField('MAX HP', '#max-hp'),
            textField('HIT DICE', '#hit-dice'),
            textField('INITIATIVE', '#initiative'),
            textField('SPEED', '#speed'),
            textField('ARMOR CLASS', '#armor-class'),
            textField('SENSES', '#senses'),
            textField('PASSIVE PERCEPTION', '#passive-perception'),
            
            // Currency
            textField('CP', '#cp'),
            textField('SP', '#sp'),
            textField('EP', '#ep'),
            textField('GP', '#gp'),
            textField('PP', '#pp'),
            
            // Array fields
            // Proficiencies with horizontal line splitting
            proficiencies_fields,
            
            // Equipment field factory
            {
                populate(data) {
                    const form = document.getElementById('character-form');
                    const equipmentEl = form.querySelector('#equipment-text');
                    if (equipmentEl && data['EQUIPMENT']) {
                        let equipmentText = '';
                        
                        if (Array.isArray(data['EQUIPMENT'])) {
                            // Handle flat list format
                            const equipList = data['EQUIPMENT'].map(item => item?.toString() || '');
                            equipmentText = equipList.join('\n');
                        } else if (typeof data['EQUIPMENT'] === 'object') {
                            // Handle structured format - unparse it
                            const unparsedLines = unparseEquipmentStructure(data['EQUIPMENT']);
                            equipmentText = unparsedLines.join('\n');
                        } else {
                            // Handle single string (fallback)
                            equipmentText = data['EQUIPMENT'].toString();
                        }
                        
                        equipmentEl.value = equipmentText;
                    }
                },
                capture(data) {
                    const form = document.getElementById('character-form');
                    const equipmentText = form.querySelector('#equipment-text')?.value || '';
                    if (equipmentText.trim()) {
                        const lines = equipmentText.split('\n').map(line => line.trim()).filter(line => line);
                        try {
                            // Parse equipment text into structured format
                            const structuredEquipment = parseEquipmentStrings(lines);
                            data['EQUIPMENT'] = structuredEquipment;
                        } catch (error) {
                            // Fallback to list format if parsing fails
                            console.warn('Equipment parsing failed, falling back to list format:', error);
                            data['EQUIPMENT'] = lines;
                        }
                    } else {
                        data['EQUIPMENT'] = {};
                    }
                }
            },
            
            // Dynamic list field factories
            attacksField(),
            nameDescPairs('FEATURES', '.feature-item', addFeature),
            fontField('FEATURES FONT', 'features-render'),
            fontField('MAGIC FONT', 'magic-render', ['separate']),
            magicField()
        ];

        function parseYAMLIntoForm(yamlText) {
            try {
                // Use js-yaml to parse the YAML
                const data = jsyaml.load(yamlText);
                if (!data) return;

                // Store original data for passthrough of unknown fields
                originalYamlData = structuredClone(data);

                // Populate all fields using message-passing
                FIELDS.forEach(field => field.populate(data));
                
                
            } catch (error) {
                throw new Error('YAML parsing failed: ' + error.message);
            }
        }


        function ifDNDfalse(value) {
            // Following \ifDNDfalse semantics: undefined, empty, "0", or "false" are false
            // Convert to string for comparison to handle both numeric and string values
            if (value === undefined || value === null) return true;
            const valueStr = value.toString().toLowerCase();
            return valueStr === '' || valueStr === '0' || valueStr === 'false';
        }

        function createYAMLContent() {
            const form = document.getElementById('character-form');
            // Start with original data to preserve unknown fields, or empty object if none
            const data = originalYamlData ? structuredClone(originalYamlData) : {};
            FIELDS.forEach(field => field.capture(data));

            // Use js-yaml to serialize the data structure
            return jsyaml.dump(data, { 
                indent: 2,
                noRefs: true,
                sortKeys: false 
            });
        }

        function generateYAML() {
            document.getElementById('yaml-output').value = createYAMLContent();
        }

        function copyYAML() {
            const yamlOutput = document.getElementById('yaml-output');
            yamlOutput.select();
            document.execCommand('copy');
            alert('YAML copied to clipboard!');
        }

        function updateDownloadButtonText() {
            const filename = getCharacterFilename();
            const downloadButton = document.querySelector('[onclick="downloadYAML()"]');
            downloadButton.innerHTML = `Download <tt>${filename}</tt>`;
        }
        

        function getCharacterFilename(extension = 'yaml') {
            // Get character name, or fall back to class name if no character name
            const characterName = document.querySelector('#character-name')?.value?.trim() || '';
            const className = document.querySelector('#class')?.value?.trim() || '';
            
            const baseName = characterName || className || 'character';
            
            // Replace spaces (including non-breaking spaces) with regular spaces, then convert to dash
            const cleanName = baseName.toLowerCase()
                .replace(/[\s\u00A0]+/g, '-')  // Replace spaces and non-breaking spaces with dash
                .replace(/[^a-z0-9-]/g, '')   // Remove other non-alphanumeric chars except dash
                .replace(/--+/g, '-')         // Replace multiple dashes with single dash
                .replace(/^-+|-+$/g, '')      // Remove leading/trailing dashes
                || 'character';
            return `${cleanName}.${extension}`;
        }

        function updateDownloadButtonText() {
            const downloadButton = document.querySelector('button[onclick="downloadYAML()"]');
            if (downloadButton) {
                const filename = getCharacterFilename();
                downloadButton.innerHTML = `Download <tt>${filename}</tt>`;
            }
        }

        function downloadYAML() {
            // Generate YAML content using the shared function
            const yamlContent = createYAMLContent();
            
            // Use consistent filename
            const filename = getCharacterFilename();
            
            // Create download
            const blob = new Blob([yamlContent], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        async function generatePDF() {
            try {
                // Generate YAML content using the shared function
                const yamlContent = createYAMLContent();
                
                // Send YAML directly to server (not as parameter)
                const response = await fetch('https://www.cs.tufts.edu/~nr/cgi-bin/render-charsheet.cgi', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/yaml; charset=utf-8',
                    },
                    body: yamlContent
                });
                
                // Get the blob and open it in a new window
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                window.open(url, '_blank');
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                alert(`Failed to generate PDF: ${error.message}. Please check that the server is running and accessible.`);
            }
        }

        // ===============================================
        // Equipment Format Conversion Functions
        // ===============================================
        
        // Category mapping (from Lua charsheet parser)
        const categoryMap = {
            "heavy weapon": "HEAVY WEAPONS",
            "normal weapon": "NORMAL WEAPONS", 
            "light weapon": "LIGHT WEAPONS",
            "shield": "SHIELDS",
            "heavy armor": "HEAVY ARMOR",
            "heavy armour": "HEAVY ARMOR",
            "normal armor": "MEDIUM ARMOR",
            "normal armour": "MEDIUM ARMOR", 
            "medium armor": "MEDIUM ARMOR",
            "medium armour": "MEDIUM ARMOR",
            "light armor": "LIGHT ARMOR",
            "light armour": "LIGHT ARMOR",
            "heavy item": "HEAVY ITEMS",
            "slotted item": "SLOTTED ITEMS",
            "free item": "SMALL ITEMS",
            "small item": "SMALL ITEMS",
            "stored": "STORED ITEMS",
            "stored item": "STORED ITEMS",
        };

        function stripS(s) {
            return s.endsWith('s') ? s.slice(0, -1) : s;
        }

        function getCategory(s) {
            return categoryMap[stripS(s.toLowerCase())];
        }

        function capitalize(s) {
            return s.replace(/\b\w+/g, word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            );
        }

        function formatCategoryName(category) {
            return capitalize(category.toLowerCase().replace(/s$/, ''));
        }

        // Equipment format detection
        function isStringListWithCategories(equipmentData) {
            if (!Array.isArray(equipmentData) || equipmentData.length === 0) {
                return false;
            }
            if (typeof equipmentData[0] !== 'string') {
                return false;
            }
            // Check if any item has category syntax
            return equipmentData.some(item => 
                typeof item === 'string' && (item.includes(':') || item.startsWith('-'))
            );
        }

        function isStructuredObject(equipmentData) {
            if (typeof equipmentData !== 'object' || Array.isArray(equipmentData) || !equipmentData) {
                return false;
            }
            return Object.keys(equipmentData).length > 0;
        }

        // Parse equipment strings (port of Lua function)
        function parseEquipmentStrings(lines) {
            const equipment = {};
            let i = 0;

            function add(category, item) {
                if (!equipment[category]) {
                    equipment[category] = [];
                }
                equipment[category].push(item);
            }

            while (i < lines.length) {
                const line = lines[i].trim();
                const blockHeader = line.match(/^(.+):$/);
                
                if (line === "") {
                    // Skip empty lines
                    i++;
                } else if (blockHeader && getCategory(blockHeader[1])) {
                    // Block format category header: "CATEGORY:"
                    const cat = getCategory(blockHeader[1]);
                    equipment[cat] = equipment[cat] || []; // populate even if no items follow
                    i++;
                    while (i < lines.length && /^\s*-\s/.test(lines[i])) {
                        const item = lines[i].replace(/^\s*-\s+/, "").trim();
                        add(cat, item);
                        i++;
                    }
                } else if (blockHeader) {
                    console.warn(`Unknown equipment category "${blockHeader[1]}"`);
                    i++;
                } else if (/^\S.*:/.test(line)) {
                    // Inline format: "CATEGORY: Item Name"
                    const match = line.match(/^([^:]+?):\s*(.*)$/);
                    if (match) {
                        const [, cat, item] = match;
                        if (getCategory(cat.trim())) {
                            add(getCategory(cat.trim()), item.trim());
                        } else {
                            console.warn(`Unknown equipment category "${cat}" in line "${line}"`);
                        }
                    }
                    i++;
                } else {
                    add('SLOTTED ITEMS', line); // heuristic category
                    i++;
                }
            }
            return equipment;
        }

        // Convert structured equipment back to string list format
        function unparseEquipmentStructure(structuredEquipment) {
            const lines = [];
            
            for (const [category, items] of Object.entries(structuredEquipment)) {
                if (Array.isArray(items)) {
                    if (items.length === 1) {
                        // Single item: use inline format
                        const formattedCategory = formatCategoryName(category);
                        lines.push(`${formattedCategory}: ${items[0]}`);
                    } else {
                        // Multiple items or empty: use block format
                        const formattedCategory = formatCategoryName(category);
                        lines.push(`${formattedCategory}s:`);
                        items.forEach(item => {
                            lines.push(`- ${item}`);
                        });
                    }
                }
            }
            
            return lines;
        }

        // Deep equality check for objects/arrays
        function deepEqual(obj1, obj2) {
            if (obj1 === obj2) return true;
            
            if (obj1 == null || obj2 == null) return obj1 === obj2;
            
            if (typeof obj1 !== typeof obj2) return false;
            
            if (typeof obj1 !== 'object') return obj1 === obj2;
            
            if (Array.isArray(obj1) !== Array.isArray(obj2)) return false;
            
            const keys1 = Object.keys(obj1);
            const keys2 = Object.keys(obj2);
            
            if (keys1.length !== keys2.length) return false;
            
            return keys1.every(key => deepEqual(obj1[key], obj2[key]));
        }

        // Convert any equipment format to unified structured format
        function equipmentToStructured(equipmentData) {
            if (isStringListWithCategories(equipmentData)) {
                return parseEquipmentStrings(equipmentData);
            } else if (isStructuredObject(equipmentData)) {
                return equipmentData; // already in structured format
            } else if (Array.isArray(equipmentData) && equipmentData.length > 0) {
                // Traditional string list - put everything in heuristic category
                return { 'SLOTTED ITEMS': equipmentData };
            } else {
                return {}; // empty equipment
            }
        }

        // Round-trip validation function
        function validateEquipmentRoundTrip(structuredEquipment) {
            // Skip validation for empty structures
            if (!structuredEquipment || Object.keys(structuredEquipment).length === 0) {
                return structuredEquipment;
            }
            
            // Unparse to string list format
            const unparsedLines = unparseEquipmentStructure(structuredEquipment);
            
            // Parse it back
            const reparsedStructure = parseEquipmentStrings(unparsedLines);
            
            // Compare with original
            if (!deepEqual(structuredEquipment, reparsedStructure)) {
                const error = {
                    message: 'Equipment round-trip validation failed!',
                    original: structuredEquipment,
                    unparsedLines: unparsedLines,
                    reparsed: reparsedStructure
                };
                console.error(error);
                throw new Error(error.message + '\nCheck console for details.');
            }
            
            return structuredEquipment;
        }

        // ===============================================
        // Equipment UI Functions
        // ===============================================
        
        function convertEquipmentToStructured() {
            const equipmentText = document.getElementById('equipment-text').value;
            if (!equipmentText.trim()) {
                alert('No equipment text to convert!');
                return;
            }
            
            try {
                const lines = equipmentText.split('\n');
                const structured = equipmentToStructured(lines);
                const validated = validateEquipmentRoundTrip(structured);
                
                // Display result in a nice format
                let display = 'Structured Equipment:\n\n';
                for (const [category, items] of Object.entries(validated)) {
                    display += `${category}:\n`;
                    if (Array.isArray(items)) {
                        items.forEach(item => display += `  - ${item}\n`);
                    }
                    display += '\n';
                }
                
                alert(display);
                
            } catch (error) {
                alert(`Error converting equipment: ${error.message}`);
            }
        }
        
        function convertStructuredToLines() {
            const equipmentText = document.getElementById('equipment-text').value;
            if (!equipmentText.trim()) {
                alert('No equipment text to convert!');
                return;
            }
            
            try {
                const lines = equipmentText.split('\n');
                const structured = equipmentToStructured(lines);
                const validated = validateEquipmentRoundTrip(structured);
                const converted = unparseEquipmentStructure(validated);
                
                // Update the textarea with converted format
                document.getElementById('equipment-text').value = converted.join('\n');
                
                alert('Equipment converted to categorized format!');
                
            } catch (error) {
                alert(`Error converting equipment: ${error.message}`);
            }
        }

        // Test function for the equipment parsing
        function testEquipmentParsing() {
            const testCases = [
                {
                    name: "Single items",
                    input: {
                        "HEAVY WEAPONS": ["Maul"],
                        "SHIELDS": ["Shield"],
                        "SLOTTED ITEMS": ["Backpack"]
                    }
                },
                {
                    name: "Multiple items and empty",
                    input: {
                        "SLOTTED ITEMS": ["Backpack", "Bedroll", "Rations"],
                        "SMALL ITEMS": [],
                        "NORMAL WEAPONS": ["Longsword"]
                    }
                },
                {
                    name: "String list with categories",
                    input: [
                        "Heavy weapon: Greatsword",
                        "Light armor: Leather armor",
                        "Slotted items:",
                        "- Backpack",
                        "- Rations (5 days)",
                        "Small items:"
                    ]
                },
                {
                    name: "Traditional flat list", 
                    input: ["Leather armor", "Shortsword", "Backpack", "Bedroll"]
                }
            ];

            let results = 'Equipment Parsing Test Results:\n\n';
            let allPassed = true;

            testCases.forEach(testCase => {
                try {
                    const structured = equipmentToStructured(testCase.input);
                    const validated = validateEquipmentRoundTrip(structured);
                    const unparsed = unparseEquipmentStructure(validated);
                    
                    results += `‚úÖ ${testCase.name}: PASSED\n`;
                    results += `   Unparsed format:\n`;
                    unparsed.forEach(line => results += `     ${line}\n`);
                    results += '\n';
                    
                } catch (error) {
                    results += `‚ùå ${testCase.name}: FAILED\n`;
                    results += `   Error: ${error.message}\n\n`;
                    allPassed = false;
                }
            });
            
            results += allPassed ? '\nüéâ All tests PASSED!' : '\n‚ö†Ô∏è  Some tests FAILED!';
            
            // Show results in a popup and log to console
            alert(results);
            console.log('Equipment parsing test results:', results);
        }

    </script>
</body>
</html>
